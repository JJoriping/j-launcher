/**
 * 명령어의 실행을 담당하는 상수 객체이다.
 */
const COMMANDS = {
	'/': null,
	call: data => {
		Channel.callUser(data.target, data.room.id);
	},
	chance: data => {
		let tui = "";
		let chance = data.chance * 100;
		let i;

		for(i=0; i<100; i+=10){
			if(i < chance) tui += "■";
			else tui += "□";
		}
		command(`${tui} ${(chance).toFixed(2)}%`, data.room.id, 'cmd-receive', FA('random', true));
	},
	clear: data => {
		clearBoard($data.currentAct);
		command(L('cleared'), data.room.id, "cmd-receive");
	},
	coin: data => {
		let tui = "";
		let chance = data.chance;

		if(chance < 0.49) tui = L('coin-yes');
		else if(chance < 0.98) tui = L('coin-no');
		else tui = L('coin-undefined');
		command(tui, data.room.id, 'cmd-receive', FA('random', true));
	},
	dice: data => {
		let res = Math.floor(Math.random() * data.max) + 1;

		command(res.toString(), data.room.id, 'cmd-receive', FA('random', true));
	},
	help: data => {
		let pre = CMD_LIST.map(v => {
			let usage = L('cmdu-' + v).replace(/\((.+?)\)/g, (v, p1) => `<u>${p1}</u>`);

			return `<li><b>/${v} ${usage}</b><br/>${L('cmdx-' + v)}</li>`;
		}).join('');

		command("", data.room.id, 'cmd-receive', `<ul>${pre}</ul>${L('cmdx')}`);
	},
	help_opt: data => {
		let pre = OPT_KEYS.map(v => {
			return `<li><b>${v}</b><br/>${L('optx-' + v)}</li>`
		}).join('');

		command("", Activity.current.room.id, 'cmd-receive', `<ul>${pre}</ul>${L('cmdx')}`);
	},
	js: data => {
		try{ data._res = String(eval(data.data)); }
		catch(e){ data._res = e.toString(); data._addr = `<label style='color: orange;'>${FA('warning', true)}</label>`; }
		command(data._res, data.room.id, 'cmd-receive', data._addr);
	},
	note: data => {
		Channel.send('note', {
			target: data.target,
			data: data.data
		});
	},
	set: data => {
		setOpt(data.key, eval(data.value));
	},
	status: data => {
		Channel.send('status', { status: data.data });
	},
	sticker: data => {
		sendMessage('sticker', Activity.current.room, `${data.group}-${data.seq}`);
	},
	w: data => {
		Channel.send('whisper', {
			rId: Activity.current.id,
			target: data.target,
			data: data.data
		});
	}
};
/**
 * 명령어의 하위 힌트 도출을 담당하는 상수 객체이다.
 */
const CMD_SUBHINT = {
	sticker: [
		null,
		(data, argv) => {
			let R = "";

			$data._subhint = $data.myInfo.sticker.list.map(v => v.packCode).filter(v => v.indexOf(data) != -1);
			$data._subhint.forEach(v => {
				R += `<div id="chint-sub-${v}" class="chint-sub-item chint-sub-list">
					<img src="${STICKER_URL(v, 'tab_on', "type=m34_29")}" style="vertical-align: middle;"/> ${v.replace(data, `<label class="chint-match">${data}</label>`)}
				</div>`;
			});
			return R;
		},
		(data, argv) => {
			let R = "";
			let i, len = $data.myInfo.sticker.table[argv[1]];
			let preview = STICKER_URL(argv[1], 'preview', "type=p100_100");

			$data._subhint = [];
			for(i=0; i<len; i++){
				let x, y;
				
				if(data && String(i + 1).indexOf(data) == -1) continue;
				x = -108 * (i % 3);
				y = -100 * Math.floor(i / 3);
				$data._subhint.push(i + 1);
				R += `<div id="chint-sub-${i + 1}" class="chint-sub-item chint-sub-block"
					style="background: url(${preview}) ${x}px ${y}px no-repeat;">
					${i + 1}
				</div>`;
			}
			return R;
		}
	]
};
const CMD_LIST = Object.keys(COMMANDS).sort();

ipc.on('command', (ev, type, data) => COMMANDS[type](data));const FILTER_IMG = {
	filters: [{
		name: L('file-image'),
		extensions: [ 'jpg', 'png', 'gif' ]
	}],
	properties: [ "openFile" ]
};
const STATUS_CLASS = {
	'online': "online",
	'afk': "afk"
};
const CHANNEL_MENU = Remote.Menu.buildFromTemplate([
	{
		label: L('menu-actli-whisper'),
		click: () => { Activity.current.$stage.chat.val(`/w ${$data._cTarget} `).focus(); }
	},
	{
		label: L('menu-actli-note'),
		click: () => { Activity.current.$stage.chat.val(`/note ${$data._cTarget} `).focus(); }
	},
	{
		label: L('menu-actli-call'),
		click: () => Channel.callUser($data._cTarget)
	}
]);
const CHANNEL_HOST = "jjo.kr";
const ACT_OPENED = "opened";
const HISTORY_MAX = 100;
const STICKER_URL = (pack, seq, qs) => `https://ssl.phinf.net/gfmarket/${pack}/original_${seq}.png${qs ? `?${qs}` : ""}`;

/**
 * 액티비티를 정의한다.
 * 각 액티비티는 방 목록 또는 한 채팅방을 담당하며 탭으로 전환시킬 수 있다.
 * 한 채팅방은 한 채널과 연관되어 있다.
 */
class Activity{
	/**
	 * @type {Activity}
	 * 현재 액티비티 객체를 가리킨다.
	 */
	static get current(){
		return $data.acts[$data.currentAct];
	}

	constructor(id, title, ord, $obj){
		this.id = id;
		this.title = title;
		this.ord = ord;
		this.history = new ChatHistory(this);
		this.$obj = $obj;
		
		this.$stage = {
			board: $obj.children(".act-board")
				.on('scroll', e => this.onBoardScroll(e.originalEvent)),
			ghost: $obj.find(".act-ghost").on('click', e => {
				let b = this.$stage.board.get(0);

				b.scrollTop = b.scrollHeight - b.clientHeight;
				$(e.currentTarget).hide();
			}),
			menu: $obj.children(".act-menu"),
			list: $obj.children(".act-list"),
			chat: $obj.find(".act-chat")
				.on('keydown', e => this.onChatKeyDown(e))
				.on('keyup', e => this.onChatKeyUp(e))
				.on('paste', e => this.onChatPaste(e.originalEvent)),
			send: $obj.find(".act-send")
				.on('click', e => this.onSendClick(e)),
			image: $obj.find(".act-image")
				.on('click', e => this.onImageClick(e)),
			prev: $obj.find(".act-menu-prev")
				.on('click', e => this.onMenuPrevClick(e)),
			save: $obj.find(".act-menu-save")
				.on('click', e => this.onMenuSaveClick(e)),
			quit: $obj.find(".act-menu-quit")
				.on('click', e => this.onMenuQuitClick(e))
		};
		this.initChannel();
	}
	/**
	 * 채널을 초기화한다.
	 * 
	 * @param {*} $list 채널 이용자 목록을 가리키는 jQuery 객체(기본값: 액티비티 스테이지로부터 얻은 jQuery 객체)
	 */
	initChannel($list){
		if(this.id == ACT_OPENED) return;

		if(!$list) $list = this.$stage.list;
		if(OPT['channel-pw']){
			this.channel = new Channel(this.id, $list);
		}else{
			this.$stage.list.html(`
				<label>${L('act-mr-chan-no')}</label><br/>
				<button class="act-mr-chan-go-login" style="color: blue;">${L('act-mr-chan-go-login')}</button><br/>
				<button class="act-mr-chan-go-email" style="color: blue;">${L('act-mr-chan-go-email')}</button>
			`);
			this.$stage.list.children(".act-mr-chan-go-login").on('click', e => {
				prompt(L('act-mr-chan-go-login')).then(pw => {
					if(!pw) return;
					setOpt('channel-pw', pw);
					
					Channel.init($data.myInfo.profile.id, pw);
					for(let i in $data.acts) $data.acts[i].initChannel();
				});
			});
			this.$stage.list.children(".act-mr-chan-go-email").on('click', e => {
				$.post(`http://${CHANNEL_HOST}/ncc/email`, { id: $data.myInfo.profile.id }, res => {
					if(res) $dialog('ce', true).show().find("#diag-ce-target").html(L('diag-ce-target', $data.myInfo.profile.id));
				});
			});
		}
	}
	/**
	 * 이 액티비티가 가지는 방 정보를 설정하고 방 정보에 맞게 DOM 객체를 수정한다.
	 * 
	 * @param {*} room 방 정보
	 */
	setRoom(room){
		this.room = room;
		this.nCount = 0;

		$(`#at-item-${this.id}`)[room.isPublic ? 'removeClass' : 'addClass']("at-item-locked");
		this.$stage.menu.children(".act-menu-title").html(`
			<label class="actm-title-name"><b>${room.name}</b></label><i/>
			<label class="actm-title-user">${L('act-mr-user', room.userCount)}</label><i/>
			<label class="actm-title-cafe">${room.cafe.name}</label><i/>
			<label class="actm-title-attr">${room.isPublic ? L('act-mr-public') : L('act-mr-private')}</label>
		`);
	}
	/**
	 * 이 액티비티가 포함한 채팅 기록을 저장한다.
	 * 
	 * @param {string} path 기록될 파일의 경로
	 */
	requestSaveChat(path){
		let data = [];

		this.$stage.board.children(".act-talk").each((i, o) => {
			let $o = $(o);

			data.push(`[${$o.children(".actt-stamp").html()}] ${$o.children(".actt-user").attr('title')}: ${$o.children(".actt-body").html().trim()}`);
		});
		ipc.send('cojer', "Save", {
			path: path,
			data: data.join('\n')
		});
	}
	/**
	 * 이전 대화를 불러오도록 요청한다.
	 */
	requestPrevChat(){
		let v = this._prevChat;
		
		this._prevChat = Math.max(0, v - OPT['prev-per-req']);
		ipc.send('cojer', "PrevChat", {
			room: this.room,
			from: this._prevChat + 1,
			to: v
		});
	}
	/**
	 * 이 액티비티가 가리키는 방에서 퇴장한다.
	 */
	requestQuit(){
		ipc.send('cojer', "Quit", {
			room: this.room
		});
	}

	onBoardScroll(e){
		if(checkScrollBottom(e.currentTarget)) this.$stage.ghost.hide();
	}
	onChatKeyDown(e){
		switch(e.key){
			case '/':
				if(!e.currentTarget.value){
					$data._hint = true;
					setCommandHint(true, "/");
				}
				break;
			case 'Enter':
				if(!e.shiftKey){
					if($data._shIndex >= 0){
						let argv = this.$stage.chat.val().split(' ');

						argv[$data._cmdArgIndex] = $data._subhint[$data._shIndex];
						this.$stage.chat.val(argv.join(' ') + " ");
					}else if($data._hint && $data._hIndex >= 0){
						this.$stage.chat.val("/" + $data._hList[$data._hIndex] + " ");
					}else{
						this.$stage.send.trigger('click');
					}
					e.preventDefault();
				}
				break;
			case 'Escape':
				if($data._hint){
					setCommandHint(false);
				}else{
					this.$stage.ghost.hide();
				}
				break;
			case 'ArrowUp':
			case 'ArrowDown':
				if($data._hint){
					let isSub = false;
					let iKey, iList;
					
					if($data._subhint){
						isSub = true;
						iKey = '_shIndex';
						iList = '_subhint';
					}else{
						iKey = '_hIndex';
						iList = '_hList';
					}
					if($data[iKey] == -1){
						$data[iKey] = 0;
					}else{
						if(e.key == 'ArrowUp'){
							if(!$data[iKey]--) $data[iKey] = $data[iList].length - 1;
						}else{
							if(++$data[iKey] == $data[iList].length) $data[iKey] = 0;
						}
					}
					if(isSub){
						$(".chint-sub-item.chint-chosen").removeClass("chint-chosen");
						let vp = $(`#chint-sub-${$data._subhint[$data._shIndex]}`).addClass("chint-chosen")[0].getBoundingClientRect();
						let di1 = window.innerHeight - this.$stage.chat.height() - vp.height;
						let di2 = di1 + vp.height - $stage.cmdHint.height();

						if(vp.top > di1) $stage.cmdHint[0].scrollTop += vp.top - di1;
						else if(vp.top < di2) $stage.cmdHint[0].scrollTop += vp.top - di2;
					}else setCommandHint(true, e.currentTarget.value, $data[iList][$data[iKey]]);
					e.preventDefault();
				}else{
					if(e.key == 'ArrowUp') Activity.current.history.up();
					else Activity.current.history.down();
				}
				break;
			default: return;
		}
	}
	onChatKeyUp(e){
		if($data._hint){
			if(e.key == 'ArrowUp' || e.key == 'ArrowDown') return;
			$data._hIndex = -1;
			setCommandHint(true, e.currentTarget.value);
		}
	}
	onChatPaste(e){
		let files, len, i;

		switch(e.type){
			case "drop":
				files = e.dataTransfer.files;
				len = files.length;
				if(!len || files[0].kind == "string") return true;

				$data._uploading = files[0].path.replace(/\\/g, "/");
				$dialog('upload', true).show();
				$stage.diag.uploadImg.attr('src', $data._uploading);
				if(OPT['no-ask-upload']) $stage.diag.uploadOK.trigger('click');
				break;
			case "paste":
				files = e.clipboardData.items;
				len = files.length;
				if(!len || files[0].kind == "string") return true;

				$data._uploading = Clipboard.readImage();
				$dialog('upload', true).show();
				$stage.diag.uploadImg.attr('src', $data._uploading.toDataURL());
				$data._uploading = $data._uploading.toPNG();
				if(OPT['no-ask-upload']) $stage.diag.uploadOK.trigger('click');
				break;
		}
		return false;
	}
	onSendClick(e){
		let text = this.$stage.chat.val();

		if(text.length > 500) if(!confirm(L('error-101'))){
			return this.$stage.chat.val(text.slice(0, 500));
		}
		sendMessage("text", this.room, text);
		setCommandHint(false);
		this.$stage.chat.val("");
	}
	onImageClick(e){
		Remote.dialog.showOpenDialog(Remote.getCurrentWindow(), FILTER_IMG, files => {
			if(!files) return;
			files.forEach(v => sendMessage('image', this.room, v));
		});
	}
	onMenuPrevClick(e){
		this.$stage.prev.prop('disabled', true);
		setTimeout(() => this.$stage.prev.prop('disabled', false), 1000);

		this.requestPrevChat();
	}
	onMenuSaveClick(e){
		Remote.dialog.showSaveDialog(Remote.getCurrentWindow(), {
			title: L('act-mr-save'),
			defaultPath: `${this.room.name}-${Date.now()}.txt`
		}, path => this.requestSaveChat(path.replace(/\\/g, "/")));
	}
	onMenuQuitClick(e){
		if(!confirm(L('sure-quit', this.room.name))) return;

		this.requestQuit();
	}
}

/**
 * 채널을 정의한다.
 * 채널에 접속하여 쪼런처를 이용하는 사람들에게 부가 기능을 제공한다.
 */
class Channel{
	/**
	 * 주어진 인증 정보로 채널 접속을 시도한다.
	 * 접속에 성공하는 경우 Channel 클래스의 정적 멤버 socket을 통해 통신할 수 있다.
	 * 
	 * @param {string} id 네이버 아이디
	 * @param {string} pw 채널 암호
	 */
	static init(id, pw){
		let socket = new WebSocket(`ws://${CHANNEL_HOST}:525/${id}@${pw}`);
		
		if(Channel.socket){
			Channel._queue = [];
			Channel.socket.onmessage = undefined;
			Channel.socket.onclose = undefined;
			Channel.socket.close();
			delete Channel.socket;
		}
		socket.onmessage = Channel.onMessage;
		socket.onclose = Channel.onClose;
	}
	/**
	 * 채널로 정보를 전송한다.
	 * 채널에 접속한 상태가 아닌 경우 큐에 정보를 저장한다.
	 * 
	 * @param {string} type 정보의 유형
	 * @param {string} data 정보
	 */
	static send(type, data){
		if(!data) data = {};
		data.type = type;
		data = JSON.stringify(data);

		if(Channel.socket) Channel.socket.send(data);
		else Channel._queue.push(data);
	}
	/**
	 * send() 메소드 등에 의해 큐에 저장된 정보를 즉시 채널로 전송하고 큐를 비운다.
	 * 
	 * @param {WebSocket} socket 웹소켓 객체
	 */
	static flushQueue(socket){
		Channel.socket = socket;
		while(Channel._queue[0]) socket.send(Channel._queue.shift());
	}
	/**
	 * 채널에 접속해 있는 해당 아이디를 가진 사용자를 호출한다.
	 * 
	 * @param {string} id 네이버 아이디
	 * @param {string} rId 채팅방 식별자(기본값: 현재 채팅방 식별자)
	 */
	static callUser(id, rId){
		Channel.send('call', {
			rId: rId || Activity.current.room.id,
			target: id
		});
	}
	/**
	 * 주어진 정보를 바탕으로 사용자 정보를 갱신한다.
	 * 
	 * @param {*} user 사용자 정보
	 */
	static updateUser(user){
		let $items = $(`.actli-${user.id}`);
		let status = global.LANG[`diag-status-${user.status}`] || user.status;
		let title = `${user.nickname} (${user.id})\n${status}`;

		$items.attr('title', title);
		$items.children(".act-list-item-status")
			.removeClass("actli-status-online actli-status-custom actli-status-afk")
			.addClass(`actli-status-${STATUS_CLASS[user.status] || 'custom'}`);
		$items.find(".act-list-item-nick").html(user.nickname);
		$items.children(".act-list-item-exordial").html(user.exordial);
	}
	static onMessage(e){
		let data = JSON.parse(e.data);
		let chan = ($data.acts[data.rId] || {}).channel;

		switch(data.type){
			case 'welcome':
				Channel.flushQueue(e.target);
				break;
			case 'error':
				error(data.code, data.msg);
				break;
			case 'conn':
				chan.list.push(data.user);
				chan.renderList();
				break;
			case 'disconn':
				chan.list = chan.list.filter(v => v.id != data.user.id);
				chan.renderList();
				break;
			case 'list':
				chan.list = data.list;
				chan.renderList();
				break;
			case 'notes':
				processNotes(data);
				break;
			case 'user':
				Channel.updateUser(data.user);
				break;
			case 'whisper':
				processWhisper(data);
				break;
			default:
				console.warn("Unhandled data: ", data);
		}
	}
	static onClose(code){
		setOpt('channel-pw');
		$(".act-list").addClass("act-list-closed").html(`
			<label>${L('act-mr-chan-closed')}</label><br/>
			<button style="color: blue;" onclick="Activity.current.initChannel();">${L('act-mr-chan-retry')}</button>
		`);
	}

	constructor(rId, $list){
		this.rId = rId;
		this.$list = $list;
		this.list = [];

		Channel.send('join', { rId: rId });
	}
	renderList(){
		this.$list.removeClass("act-list-closed").empty();
		this.list.forEach(v => {
			let $item;

			this.$list.append($item = $(`
				<div id="actli-${this.rId}-${v.id}" class="act-list-item actli-${v.id}">
					<div class="act-list-item-status"/>
					<div class="act-list-item-name ellipse">
						<label class="act-list-item-nick"/>
						<label class="act-list-item-id"> (${v.id})</label>
					</div>
					<div class="act-list-item-exordial ellipse"/>
				</div>
			`.trim()));
			Channel.updateUser(v);
			$item.on('click', this.onClick);
			if(v.id == $data.myInfo.profile.id) $item.addClass("act-list-item-me");
		});
	}
	onClick(e){
		$data._cTarget = e.currentTarget.id.split('-')[3];
		CHANNEL_MENU.popup(Remote.getCurrentWindow());
	}
	close(){
		Channel.send('leave', { rId: this.rId });
	}
}
Channel._queue = [];

/**
 * 채팅 내역을 정의한다.
 * 사용자의 키 입력에 따라 내역을 조회할 수 있다.
 */
class ChatHistory{
	constructor(activity){
		this.activity = activity;
		this.list = [];
		this.index = -1;
	}

	/**
	 * 입력 내역에 주어진 내용을 추가한다.
	 * 
	 * @param {string} data 내용
	 */
	put(data){
		if(this.list.unshift(data) > HISTORY_MAX){
			this.list.pop();
		}
		this.index = -1;
	}

	/**
	 * 내역을 위로 하나 탐색하여 연결된 액티비티의 입력란에 넣는다.
	 */
	up(){
		let chat = this.activity.$stage.chat[0];
		let len = this.list.length;

		if(chat.selectionStart + chat.selectionEnd > 0) return;
		if(!len) return;

		this.index = Math.min(this.index + 1, len - 1);
		chat.value = this.list[this.index];
	}

	/**
	 * 내역을 아래로 하나 탐색하여 연결된 액티비티의 입력란에 넣는다.
	 */
	down(){
		let chat = this.activity.$stage.chat[0];

		if(chat.selectionStart != chat.selectionEnd || chat.selectionEnd != chat.value.length) return;
		if(!this.list.length) return;

		this.index = Math.max(this.index - 1, 0);
		chat.value = this.list[this.index];
	}
}const OPT_KEYS = [
	"auto", "block", "block-log", "channel-pw", "idle-time", "max-chat", "mute",
	"no-ask-upload", "prev-per-req", "status-list", "viewer-resize"
];
let $stage;
let $sound;

$(() => {
	$data.localId = 0;
	// 스테이지 등록
	$stage = {
		body: $("body"),
		diag: {
			loginCaptcha: $("#diag-login-captcha-box"),
			loginOK: $("#diag-login-ok"),
			loginOut: $("#diag-login-output"),
			uploadImg: $("#diag-upload-img"),
			uploadOK: $("#diag-upload-ok"),
			ceOK: $("#diag-ce-ok"),
			statusList: $("#diag-status-list"),
			statusOK: $("#diag-status-ok")
		},
		actTab: $("#act-tab"),
		acts: $("#activities"),
		cmdHint: $("#command-hint")
	};
	// 소리 등록
	$sound = {};
	[
		'k', 'alarm'
	].map(v => $sound[v] = new Audio(`media/${v}.mp3`));
	// 전역 입력 핸들링 / 유휴 상태 검사
	window.onmousemove = e => {
		breakIdle();
	};
	window.onkeydown = e => {
		breakIdle();
		switch(e.key){
			case 'Enter':
				$(".dialog:visible .ok-button:last").trigger('click');
				break;
			case 'Escape':
				$(".dialog:visible:last").hide();
				break;
			case 'Tab':
				if(e.ctrlKey){
					let $list = $(".at-item");
					let $c = $(".at-current");
					let len = $list.length;

					if(e.shiftKey) $c = $c.prev()[0];
					else $c = $c.next()[0];
					if(!$c) $c = $list.get(!e.shiftKey - 1);
					
					setActivity($c.id.slice(8));
				}
				break;
			default: return;
		}
	};
	setInterval(checkIdle, 1000);
	// 탭 순서 불러오기
	loadTabOrdinal();
	// 창에 드롭하는 경우
	document.body.addEventListener('dragenter', e => {
		$data._dType = e.dataTransfer.items[0].kind;
	});
	document.body.addEventListener('dragover', e => {
		$stage.body.addClass("dark-body");
		if($data._dType != "string"){
			e.preventDefault();
			e.stopPropagation();
		}
	});
	document.body.addEventListener('dragleave', e => {
		$stage.body.removeClass("dark-body");
	});
	document.body.addEventListener('drop', e => {
		$stage.body.removeClass("dark-body");
		if(!Activity.current.onChatPaste(e)){
			e.preventDefault();
			e.stopPropagation();
		}
	});
	// 로그인 대화 상자
	$stage.diag.loginOK.on('click', e => {
		$stage.diag.loginOK.prop('disabled', true);
		$stage.diag.loginOut.css('color', "").html("");
		ipc.send('cojer', 'Login', {
			id: $("#diag-login-id").val(),
			pw: $("#diag-login-pw").val(),
			captcha: $("#diag-login-captcha").val(),
			captchaKey: $data._ckey,
			auto: $("#diag-login-auto").is(':checked'),
			disposable: $("#diag-login-disposable").is(':checked')
		});
	});
	// 업로드 대화 상자
	$stage.diag.uploadOK.on('click', e => {
		if($("#diag-upload-auto").is(':checked')) setOpt('no-ask-upload', true);
		$dialog('upload').hide();
		sendMessage('image', Activity.current.room, $data._uploading);
		delete $data._uploading;
	});
	// 채널 이메일 대화 상자
	$stage.diag.ceOK.on('click', e => {
		let pw = $("#diag-ce-pass").val();

		if(pw.length < 4 || pw.length > 20) return error(102);
		$stage.diag.ceOK.prop('disabled', true);
		$("#diag-ce-output").empty();
		$.post(`http://${CHANNEL_HOST}/ncc/set`, {
			key: $("#diag-ce-serial").val(),
			id: $data.myInfo.profile.id,
			pw: pw,
			nickname: $data.myInfo.profile.nickname
		}, res => {
			$stage.diag.ceOK.prop('disabled', false);
			if(res.error) $("#diag-ce-output").html(L(`error-${res.error}`));
			else{
				notify(L('ce-ok'));
				setOpt('channel-pw', pw);
				$dialog('ce').hide();
				location.reload();
			}
		});
	});
	// 상태 대화 상자
	$stage.diag.statusOK.on('click', e => {
		Channel.send('status', { status: $stage.diag.statusList.val() });
		$dialog('status').hide();
	});
	// 특수 액티비티 등록
	$data.acts = {};
	$data.currentAct = ACT_OPENED;
	createActivity(ACT_OPENED, L('act-or-title'), `
		<select id="act-or-cafe-list">
			<option>${L('loading')}</option>
		</select>
		<div id="act-or-room-list"></div>
	`);
	$stage.roomList = $("#act-or-room-list");
	$stage.cafeList = $("#act-or-cafe-list").on('mousedown', e => {
		$stage.cafeList.off('mousedown').children("option:first-child").html(L('act-or-cafe-list')).prop('disabled', true);
	}).on('change', e => {
		$data.currentCafe = $data.myInfo.cafeList[$stage.cafeList.val()];
		ipc.send('cojer', 'OpenRoomList', {
			cafe: $data.currentCafe
		});
	});
	// 자동 로그인 / 세션 처리
	if(OPT.auto) ipc.send('cojer', 'Login', OPT.auto);
	else ipc.send('cojer', 'CheckAuth');
});
/**
 * 명령어 사용에 대한 메시지를 출력한다.
 * 
 * @param {*} msg 메시지
 * @param {string} rId 출력할 채팅방 식별자(기본값: 현재 채팅방)
 * @param {string} group 채팅 jQuery 객체에 부가적으로 넣을 클래스의 접미어(기본값: 없음)
 * @param {string} addPre 기본 접두어에서 부가적으로 넣을 접두어(기본값: 없음)
 * @returns {*} 새로 생성된 채팅 jQuery 객체
 */
function command(msg, rId, group, addPre){
	let $R = emulateMessage("command", msg, `<label style="color: gray;">${FA('gear')}</label>${addPre || " "}`);

	if(group) $R.addClass(`act-talk-${group}`);
	return $R;
}
ipc.on('event', (ev, type, data) => {
	switch(type){
		case 'login-ok':
			$data.myInfo = data;
			$stage.diag.loginOK.prop('disabled', false);
			notify(L('login-ok'));
			$dialog('login').hide();
			renderMyCafes();
			ipc.send('cojer', 'MyRoomList');
			break;
		case 'login-no':
			$stage.diag.loginOK.prop('disabled', false);
			$stage.diag.loginOut.css('color', "red").html(data);
			notify(L('login-no'), data);
			if(data.indexOf("img") != -1){
				$data._ckey = data.match(/key=(\w+)/)[1];
				$stage.diag.loginCaptcha.show();
			}
			break;
		case 'logout':
			setOpt('auto');
			setOpt('channel-pw');
			alert(L('logout'));
			break;
		case 'open-rooms':
			renderOpenRooms(data);
			break;
		case 'my-rooms':
			renderMyRooms(data);
			if(localStorage.hasOwnProperty('recentAct')){
				setActivity(localStorage.getItem('recentAct'));
			}
			if(OPT['channel-pw']) Channel.init($data.myInfo.profile.id, OPT['channel-pw']);
			break;
		case 'sess-msg':
			processMessage(data, false, true);
			break;
		case 'sess-err':
			console.error(data);
			break;
		case 'sess-progress':
			processProgress(data);
			break;
		case 'prev-chat':
			data.reverse().forEach(v => processMessage(v, true));
			break;
		case 'chan-list':
			$stage.acts.toggleClass("channel-list-collapsed");
			break;
		case 'chat-image':
			Activity.current.$stage.board.find("img:last").trigger('click');
			break;
		case 'error':
			error(data.code, data.msg);
			break;
		case 'set-chat':
			Activity.current.$stage.chat.val(data.data);
			break;
		case 'join':
			renderMyRooms([ data ], true);
			setActivity(data.id.replace(":", "-"));
			saveTabOrdinal();
			break;
		case 'quit':
			removeActivity(data.id.replace(":", "-"));
			saveTabOrdinal();
			break;
	}
});

/**
 * 새 액티비티를 생성하고 탭을 갱신한다.
 * 
 * @param {string} id 액티비티 식별자 
 * @param {string} title 탭 제목
 * @param {*} $obj 액티비티 내용. 이 함수 내에서는 생성되는 액티비티 자체로 취급한다.
 * @returns {Activity} 생성된 액티비티
 */
function createActivity(id, title, $obj){
	let ord = $data.tabOrdinal[`at-item-${id}`] || Object.keys($data.acts).length;

	$stage.acts.append($obj = $(`<div id="act-${id}" class="activity">`).html($obj));
	$data.acts[id] = new Activity(id, title, ord, $obj);

	renderActTab();
	return $data.acts[id];
}
/**
 * 해당 액티비티를 목록에서 제외시키고 탭을 갱신한다.
 * 
 * @param {string} id 액티비티 식별자
 */
function removeActivity(id){
	$(`#act-${id}`).remove();
	if($data.acts[id].channel) $data.acts[id].channel.close();
	delete $data.acts[id];
	if($data.currentAct == id) setActivity(ACT_OPENED);

	renderActTab();
}
/**
 * 현재 액티비티를 설정한다.
 * 
 * @param {string} id 액티비티 식별자
 */
function setActivity(id){
	let cr;

	$data.currentAct = id;
	localStorage.setItem('recentAct', id);
	$(".act-talk-last").remove();
	if(Activity.current && Activity.current.nCount > 0){
		$(`#actt-${id}-${Activity.current.nStartId}`).before(`<div class="act-talk act-talk-last"/>`);
		Activity.current.nCount = 0;
	}
	$(".at-current").removeClass("at-current");
	$(`#at-item-${id}`).removeClass("at-notify").addClass("at-current")
		.children(".ati-count").hide();
	$(".activity").hide();
	$(`#act-${id}`).show();
	if(id != ACT_OPENED && (cr = Activity.current.room)){
		if(!Activity.current.hasOwnProperty('_prevChat') && cr.lastMsgSn > 0){
			Activity.current._prevChat = cr.lastMsgSn;
			Activity.current.requestPrevChat();
		}
	}
	Activity.current.$stage.chat.focus();
}
/**
 * 탭을 갱신한다. 현재 생성된 액티비티가 나타난다.
 */
function renderActTab(){
	$stage.actTab.empty();
	Object.keys($data.acts).map(v => $data.acts[v]).sort((a, b) => a.ord - b.ord).forEach(v => {
		$stage.actTab.append($(`
			<div id="at-item-${v.id}" class="at-item ellipse${(v.room && !v.room.isPublic) ? " at-item-locked" : ""}" draggable="true" onclick="setActivity('${v.id}');">
				<label class="ati-count" style="display: none;"></label>
				<i class="fa fa-lock ati-locked"/>
				<label>${v.title}</label>
			</div>
		`.trim())
			.on('dragstart', onTabDragStart)
			.on('dragenter', onTabDragEnter)
			.on('dragend', onTabDragEnd)
		);
	});
	function onTabDragStart(e){
		$data._movingTab = $(e.currentTarget);
		$stage.actTab.on('dragenter', onTabDragEnter);

		e.originalEvent.dataTransfer.setData('text/plain', e.currentTarget.id);
	}
	function onTabDragEnter(e){
		let $t = $(e.originalEvent.target);
		
		if($t.attr('id') == "act-tab"){
			$t.children(":last-child").after($data._movingTab);
		}else{
			$t.before($data._movingTab);
		}
	}
	function onTabDragEnd(e){
		saveTabOrdinal();
		delete $data._movingTab;
		$stage.actTab.off('dragenter', onTabDragEnter);
	}
	$(`#at-item-${$data.currentAct}`).addClass("at-current");
}
/**
 * 탭 순서 정보를 저장한다.
 */
function saveTabOrdinal(){
	let ord = [];
	
	$stage.actTab.children().each((i, o) => ord.push(o.id));
	localStorage.setItem('tab-ordinal', ord.join(','));
	loadTabOrdinal();
}
/**
 * 탭 순서 정보를 불러온다.
 */
function loadTabOrdinal(){
	let ord = localStorage.getItem('tab-ordinal');

	if(ord) ord = ord.split(',');
	else ord = [];

	$data.tabOrdinal = {};
	ord.map((v, i) => $data.tabOrdinal[v] = i);
}
/**
 * 카페 목록을 갱신한다.
 */
function renderMyCafes(){
	$stage.cafeList.empty().append(`<option>${L('act-or-cafe-select')}</option>`);
	$data.myInfo.cafeList.forEach((v, i) => {
		$stage.cafeList.append(`<option value="${i}">${v.name}</option>`);
	});
}
/**
 * 선택된 카페에서 공개된 채팅방들의 목록을 갱신한다.
 * 
 * @param {any[]} list 공개된 채팅방 목록
 */
function renderOpenRooms(list){
	let now = Date.now();

	$stage.roomList.empty().append(`<div class="act-or-room-count">${L('act-or-room-count', list.length)}</div>`);
	list.forEach(v => {
		let id = v.id.replace(":", "-");
		let u = (now - new Date(v.updated).getTime()) * 0.001;

		if(u < 60) u = L('act-or-room-time-sec');
		else if(u < 3600) u = L('act-or-room-time-min', Math.round(u / 60));
		else if(u < 86400) u = L('act-or-room-time-hour', Math.round(u / 3600));
		else u = L('act-or-room-time-day', Math.round(u / 86400));

		$stage.roomList.append(`
			<div id="act-or-room-${id}" class="act-or-room" onclick="requestJoin('${$data.currentCafe.id}', '${v.id}');">
				<div class="acto-room-name"><b>${v.name}</b></div>
				<div class="acto-room-user">${L('act-mr-user', v.userCount)}</div>
				<div class="acto-room-attr">${v.isPublic ? L('act-mr-public') : L('act-mr-private')}</div>
				<div class="acto-room-time">${u}</div>
			</div>
		`);
	});
}
/**
 * 내 채팅방들을 각각 액티비티로 취급하여 생성한다. 이 함수는 중복 검사를 하지 않는다.
 * 
 * @param {any[]} list 내 채팅방 목록
 * @param {boolean} prevAble true인 경우 자동으로 이전 채팅 기록을 불러오지 않는다.
 */
function renderMyRooms(list, noPrev){
	list.forEach(v => {
		let act = createActivity(v.id.replace(":", "-"), v.name, `
			<div class="act-menu">
				<div class="act-menu-title ellipse"></div>
				<button class="act-menu-quit" title="${L('act-mr-quit')}">${FA('sign-out')}</button>
				<button class="act-menu-prev" title="${L('act-mr-prev')}">${FA('backward')}</button>
				<button class="act-menu-save" title="${L('act-mr-save')}">${FA('download')}</button>
			</div>
			<div class="act-board"></div>
			<div class="act-list act-list-closed"></div>
			<div class="act-ghost act-talk"></div>
			<div class="act-me">
				<textarea class="act-chat"></textarea>
				<button class="act-send">${L('act-mr-send')}</button>
				<button class="act-image">${L('act-mr-image')}</button>
			</div>
		`);
		if(noPrev) act._prevChat = 0;
		act.setRoom(v);
	});
}
/**
 * 주어진 DOM 객체의 스크롤이 가장 아래에 있는지 확인한다.
 * 
 * @param {HTMLElement} obj DOM 객체
 * @returns {boolean} true인 경우 스크롤이 가장 아래에 있는 상태이다.
 */
function checkScrollBottom(obj){
	return obj.scrollHeight - obj.scrollTop - obj.clientHeight < 1;
}
/**
 * 세션에서 받은 정보를 처리한다.
 * 
 * @param {*} data 받은 정보
 * @param {boolean} prev 이전 채팅 여부. true인 경우 가장 위에 배치된다.
 * @param {boolean} saveId true인 경우 대상 액티비티의 최근 메시지 번호가 이 정보의 번호로 설정된다.
 * @returns {*} 새로 생성된 채팅 jQuery 객체
 */
function processMessage(data, prev, saveId){
	let rId = data.room.id.replace(":", "-");
	let act = $data.acts[rId];
	if(!act){
		// 일대일 채팅이 생겼을 때 방 정보가 나타나지 않는 경우에 대한 처리
		if(!data.room.name){
			data.room.name = data.user.nickname;
			data.room.userCount = 2;
		}
		renderMyRooms([ data.room ], true);
		act = $data.acts[rId];
	}
	let $board = act.$stage.board, board = $board.get(0);
	let isMe = data.user.id == $data.myInfo.profile.id;
	let isBottom = checkScrollBottom(board);
	let now = new Date(data.time);
	let $talk;
	let content;

	if(isMe) data.user = $data.myInfo.profile;
	else if(checkBlock(`${data.user.id}: ${data.message}`)){
		if(!prev) ipc.send('block', {
			id: data.user.id,
			content: data.message,
			time: now
		});
		return;
	}
	switch(data.type){
		case "text": content = `
			${cUser(data.user)}
			<div class="actt-body">${data.preMessage || ''}${produceText(data.message)}</div>
			`;
			break;
		case "image": content = `
			${cUser(data.user)}
			<div class="actt-body">
				<img src="${data.thumb || (data.image + "?type=w128")}" onerror="$(this).replaceWith(FA('exclamation-circle'));" onload="processImage(this, '${data.image}', ${isBottom});"/>
			</div>
			`;
			break;
		case "sticker":
			if(!data.image){
				data._sticker = data.message.split('-');
				data._sticker = STICKER_URL(data._sticker[0], data._sticker[1]);
				data.xxhdpi = data._sticker + "?type=p100_100";
				data.image = data._sticker + "?type=p50_50";
			}
			content = `
			${cUser(data.user)}
			<div class="actt-body">
				<img src="${data.image}" onerror="$(this).replaceWith(FA('exclamation-circle'));" onload="processImage(this, '${data.xxhdpi}', ${isBottom});"/>
			</div>
			`;
			break;
		case "join": // 입장
		case "leave": // 퇴장
			content = cNotice(data.type,
				data.user.nickname, data.user.id
			);
			act.setRoom(data.room);
			break;
		case "invite": // 초대
			content = cNotice(data.type,
				data.user.nickname, data.user.id,
				data.target.map(v => `${v.nickname} (${v.id})`).join(', ')
			);
			act.setRoom(data.room);
			break;
		case "reject": // 강퇴
			content = cNotice(data.type,
				data.user.nickname, data.user.id,
				data.target.nickname, data.target.id
			);
			act.setRoom(data.room);
			break;
		case "changeMaster": // 방장
			content = cNotice("change-master",
				data.target
			);
			act.setRoom(data.room);
			break;
		case "changeName": // 방 제목
			content = cNotice("change-name",
				data.user.nickname, data.user.id,
				data.target
			);
			act.setRoom(data.room);
			break;
		default:
			console.log(data);
	}
	$board[prev ? 'prepend' : 'append']($talk = $(`<div id="actt-${rId}-${data.id}" class="act-talk act-talk-${data.user.id}" onclick="traceMessage('${data.user.id}');">
		${content}
		<div class="actt-stamp" title="${now.toLocaleString()}">${now.toLocaleTimeString()}</div>
	</div>`));
	if($data.currentAct != rId){
		if(act.nCount === 0) act.nStartId = data.id;
		$(`#at-item-${rId}`).addClass("at-notify")
			.children(".ati-count").show().html(++act.nCount);
	}
	if($data._traced == data.user.id) $talk.addClass("act-talk-traced");
	if(isMe){
		$talk.addClass("act-my-talk");
		if($data._$pending){
			$data._$pending.remove();
			delete $data._$pending;
		}
	}
	if(isBottom || isMe){
		board.scrollTop = board.scrollHeight - board.clientHeight;
	}else if(!prev){
		act.$stage.ghost.show().html($talk.html());
	}
	if(!prev && board.children.length > OPT['max-chat']){
		act._prevChat++;
		board.removeChild(board.children[0]);
	}
	if(saveId) act._lastMsgId = data.id;
	playSound('k');

	function cUser(user){
		return `
			<div class="actt-user ellipse" title="${user.nickname} (${user.id})">
				<div class="actt-user-image" style="background-image: url(${user.image});"/>
				${user.nickname}
			</div>
		`;
	}
	function cNotice(type, ...args){
		args.unshift("notice-" + type);

		return `<div class="actt-notice">${L.apply(this, args)}</div>`;
	}
	return $talk;
}
/**
 * 메시지 출력을 모방한다.
 * 
 * @param {string} type 모방 유형 식별자
 * @param {string} msg 메시지(기본값: "")
 * @param {string} pre 전(pre)-메시지(기본값: "")
 * @param {string} rId 채팅방 식별자(기본값: 현재 채팅방)
 * @param {*} user 사용자 정보(기본값: 내 정보)
 * @param {number} time 시간 정보(기본값: 현재)
 */
function emulateMessage(type, msg, pre, rId, user, time){
	return processMessage({
		id: `${type}-${++$data.localId}`,
		room: { id: rId || Activity.current.room.id },
		user: user || $data.myInfo.profile,
		type: "text",
		preMessage: pre || "",
		message: msg,
		time: time || Date.now()
	});
}
/**
 * 채널로부터의 쪽지를 처리한다.
 * 
 * @param {*} data 쪽지 정보
 */
function processNotes(data){
	let pre = `<label style="color: skyblue;">${FA('envelope')}</label> `;

	data.list.forEach(v => {
		emulateMessage("notes", v.data, pre, undefined, v.from, v.time);
	});
}
/**
 * 진행 이벤트를 처리한다.
 * 파일 업로드 등에서 진행 이벤트가 발생한다.
 * 
 * @param {*} data 진행 이벤트 정보
 */
function processProgress(data){
	if(!$data._$pending) return;
	$data._$pending.children(".actt-body").html(data.percent.toFixed(1) + "%");
}
/**
 * 채널로부터의 귓속말을 처리한다.
 * 
 * @param {*} data 귓속말 정보
 */
function processWhisper(data){
	let $window = Remote.getCurrentWindow();
	let pre = `<label style="color: orange;">${FA('lock')}</label> `;
	let $talk;
	let notiTitle;
	
	if(data.data === true){ // 호출
		pre = pre.replace(FA('lock'), FA('feed'));
		notiTitle = data.data = L('on-call', data.from.nickname);
		playSound('alarm');
	}else if(data.data === 1){ // 쪽지 보내기에 성공
		pre = pre.replace(FA('lock'), FA('envelope'));
		data.data = L('noted');
		notiTitle = null;
	}else{
		notiTitle = L('on-whisper', data.from.nickname);
	}
	$talk = emulateMessage('whisper', data.data, pre, data.rId, data.from)
		.addClass("act-talk-cmd-receive");

	if(notiTitle) if(!$window.isFocused() || $window.isMinimized()) notify(notiTitle, data.data);
}
/**
 * 불러온 이미지 정보를 처리한다.
 * 
 * @param {HTMLImageElement} img 이미지 DOM 객체
 * @param {string} source 원본 이미지 경로
 * @param {boolean} downScroll 스크롤 내리기 여부. true인 경우 이미지의 높이만큼 스크롤을 내린다.
 */
function processImage(img, source, downScroll){
	let $img = $(img).on('click', e => popupImage(source));

	if(downScroll) $img.parent().parent().parent().get(0).scrollTop += img.height;
}
/**
 * 불러온 텍스트 정보를 가공한다.
 * 
 * @param {string} text 텍스트
 * @returns {string} 가공된 텍스트
 */
function produceText(text){
	const TABLE = {
		'<': "&lt;", '>': "&gt;", '&': "&amp;", '\n': "<br>", ' ': "&nbsp;"
	};
	
	if(OPT['use-jom']) return JOM.parse(text
		.replace(/ /g, "&nbsp;")
		.replace(/\n/g, "\n\n")
		.replace(/(https?:\/\/.+?\.[^)]+?)(?:\s|<br>|$)/gi, (v, p1) => `[${p1}](${p1})`));
	return text
		.replace(/<|>|&|\n| /g, v => TABLE[v])
		.replace(/(https?:\/\/.+?\..+?)(?:\s|<br>|$)/gi, (v, p1) => `<a href="#" onclick="shell.openExternal('${p1}');">${p1}</a>`);
}
/**
 * 주어진 명령어의 한 인자에 대한 하위 힌트를 가공한다.
 * 
 * @param {string} cmd 명령어
 * @param {number} index 인자 번호(0은 명령어)
 * @param {string} value 현재 인자 값
 * @param {string[]} argv 전체 명령어 배열
 * @returns {string} 가공된 하위 힌트
 */
function produceSubhint(cmd, index, value, argv){
	let lister = CMD_SUBHINT[cmd];
	let R = "";

	$data._cmdArgIndex = index;
	if(!lister) return "";
	if(!lister[index]) return "";

	return lister[index](value, argv);
}
/**
 * 메시지를 전송한다.
 * 전송하려는 메시지는 현재 DOM의 상황에 따라 자동적으로 결정된다.
 * 
 * @param {string} type 정보 유형(다음 중 하나: text, image, sticker)
 * @param {*} room 보낼 채팅방 객체
 * @param {*} data 보낼 정보
 */
function sendMessage(type, room, data){
	if(!data) return;

	if(type == "text"){
		Activity.current.history.put(data);
		// 명령어 처리
		if(data[0] == '/'){
			let ci = data.indexOf(' ');
			let form;
			
			if(ci == -1) ci = data.length;
			form = {
				type: data.slice(1, ci),
				room: room,
				raw: data,
				data: data.slice(ci + 1)
			};
			command(form.raw, form.room.id, 'cmd-send');
			ipc.send('cojer', 'Command', form);
			return;
		}
		if(!data.trim()) return;
	}
	if($data._$pending) $data._$pending.remove();
	$data._$pending = emulateMessage('pending', (typeof data == "string") ? data : "...", FA('spinner fa-spin', true), room.id)
		.addClass("act-pending-talk");
	
	ipc.send('cojer', 'Send', {
		type: type,
		room: room,
		data: data
	});
}
/**
 * 명령어 힌트 상태를 설정한다.
 * 
 * @param {boolean} visible 힌트 표시 여부
 * @param {string} text 검색 문자열
 * @param {string} chosen 선택된 명령어
 */
function setCommandHint(visible, text, chosen){
	let reg;
	let argv;
	let cArg;

	$data._shIndex = -1;
	delete $data._subhint;
	if(!text){
		$data._hint = visible = false;
		$stage.cmdHint.hide();
		return;
	}
	try{
		argv = text.slice(1).split(' ');
		reg = new RegExp(`^(${argv[0]})${(argv.length > 1) ? '$' : ''}`);
	}catch(e){
		$stage.cmdHint.hide();
		return;
	}
	if(visible){
		let list = CMD_LIST.filter(v => reg.test(v));
		let res = list.map(v => `
			<li id="chint-${v}">/${v.replace(reg, "<label class='chint-match'>$1</label>")} <label class="chint-usage">${L('cmdu-' + v)}</label><div class="chint-expl">%${v}%</div></li>
		`).join('');

		if(!chosen && list.length == 1){
			chosen = list[0];
			cArg = argv.length - 1;
		}
		if(chosen){
			res = res
				.replace(`>%${chosen}%`, ` style="display: block;">${L('cmdx-' + chosen)}`)
				.replace("chint-" + chosen, `chint-${chosen}" class="chint-chosen`);
			if(cArg) res += produceSubhint(list[0], cArg, argv[cArg], argv);
		}
		$stage.cmdHint.show().html(res);
		$data._hList = list;
	}else{
		$stage.cmdHint.hide();
	}
}
/**
 * 주어진 아이디를 가진 사용자의 채팅을 강조 표시한다.
 * 
 * @param {string} id 사용자 아이디
 */
function traceMessage(id){
	let already = $data._traced == id;

	$data._traced = id;
	$(".act-talk-traced").removeClass("act-talk-traced");
	if(already) delete $data._traced;
	else $(`.act-talk-${id}`).addClass("act-talk-traced");
}
/**
 * 해당 액티비티의 채팅 내용을 비운다.
 * 
 * @param {string} id 액티비티 식별자
 */
function clearBoard(id){
	let act = $data.acts[id];
	
	act._prevChat = act._lastMsgId;
	act.$stage.board.empty();
}
/**
 * 이미지에 대한 팝업을 띄운다.
 * 
 * @param {string} url 이미지 경로
 */
function popupImage(url){
	window.open(`./viewer.pug?url=${encodeURIComponent(url)}`);
}
/**
 * 방에 입장한다.
 * 
 * @param {string} cId 입장할 채팅방이 소속된 카페의 식별자
 * @param {string} rId 입장할 채팅방의 식별자
 */
function requestJoin(cId, rId){
	if($data.acts[rId.replace(":", "-")]) return error(100);
	ipc.send('cojer', 'Join', {
		cId: cId, rId: rId
	});
}
/**
 * 소리를 재생한다.
 * 
 * @param {string} key 소리 식별자
 */
function playSound(key){
	if(OPT['mute']) return;
	$sound[key].play();
}
/**
 * 유휴 상태를 해제한다.
 */
function breakIdle(){
	if($data.isIdle){
		Channel.send('status', { status: "online" });
	}
	$data.isIdle = false;
	$data._idle = 0;
}
/**
 * 유휴 상태를 확인한다.
 */
function checkIdle(){
	if($data.isIdle) return;
	if(++$data._idle >= OPT['idle-time']){
		$data.isIdle = true;
		Channel.send('status', { status: "afk" });
	}
}
/**
 * 차단 대상인 채팅인지 검사한다.
 * 
 * @param {string} serial 채팅 구문. "(아이디): (내용)" 꼴로 주어진다.
 * @returns {boolean} 차단 대상인 경우 true
 */
function checkBlock(serial){
	let list, i;
	
	list = OPT['block'];
	for(i in list) if(serial.match(new RegExp(list[i]))) return true;

	return false;
}
/**
 * 오류를 알린다.
 * 
 * @param {number} code 오류 번호
 * @param {*} msg 부가 메시지
 */
function error(code, msg){
	alert(L(`error-${code}`, msg));
}
/**
 * 유효한 설정의 기본값을 나타낸다.
 */
const OPT_DEFAULTS = {
	'auto': {},
	'black': [],
	'black-log': "black.log",
	'channel-pw': null,
	'find-depth': 100,
	'history-max': 100,
	'idle-time': 300,
	'macro': [],
	'max-chat': 100,
	'mute': false,
	'no-ask-upload': false,
	'no-channel-notice': false,
	'no-image': false,
	'no-trace': false,
	'no-update-notice': false,
	'prev-per-req': 30,
	'status-list': [],
	'use-jom': false,
	'viewer-resize': true,
	'watch-interval': 30,
	'watch-list': [],
	'white': [],
	'youtube-view': true
};
/**
 * 유효한 설정의 목록을 나타낸다.
 */
const OPT_KEYS = Object.keys(OPT_DEFAULTS);
/**
 * 명령어의 실행을 담당하는 상수 객체이다.
 */
const COMMANDS = {
	'/': null,
	call: data => {
		Channel.callUser(data.target, data.room.id);
	},
	chance: data => {
		let tui = "";
		let chance = data.chance * 100;
		let i;

		for(i=0; i<100; i+=10){
			if(i < chance) tui += "■";
			else tui += "□";
		}
		command(`${tui} ${(chance).toFixed(2)}%`, data.room.id, 'cmd-receive', FA('random', true));
	},
	clear: data => {
		clearBoard($data.currentAct);
		command(L('cleared'), data.room.id, "cmd-receive");
	},
	coin: data => {
		let tui = "";
		let chance = data.chance;

		if(chance < 0.49) tui = L('coin-yes');
		else if(chance < 0.98) tui = L('coin-no');
		else tui = L('coin-undefined');
		command(tui, data.room.id, 'cmd-receive', FA('random', true));
	},
	dice: data => {
		let res = Math.floor(Math.random() * data.max) + 1;

		command(res.toString(), data.room.id, 'cmd-receive', FA('random', true));
	},
	help: data => {
		let pre = CMD_LIST.map(v => {
			let usage = L('cmdu-' + v).replace(/\((.+?)\)/g, (v, p1) => `<u>${p1}</u>`);

			return `<li><b>/${v} ${usage}</b><br/>${L('cmdx-' + v)}</li>`;
		}).join('');

		command("", data.room.id, 'cmd-receive', `<ul>${pre}</ul>${L('cmdx')}`);
	},
	help_opt: data => {
		let pre = OPT_KEYS.map(v => {
			return `<li><b>${v}</b><br/>${L('optx-' + v)}</li>`
		}).join('');

		command("", Activity.current.room.id, 'cmd-receive', `<ul>${pre}</ul>${L('cmdx')}`);
	},
	image: data => {
		sendMessage('image', Activity.current.room, data.data);
	},
	initialize: data => {
		setOpt(OPT_DEFAULTS);
		location.reload();
	},
	js: data => {
		try{ data._res = String(eval(data.data)); }
		catch(e){ data._res = e.toString(); data._addr = `<label style='color: orange;'>${FA('warning', true)}</label>`; }
		command(data._res, data.room.id, 'cmd-receive', data._addr);
	},
	note: data => {
		Channel.send('note', {
			target: data.target,
			data: data.data
		});
	},
	set: data => {
		setOpt(data.key, eval(data.value));
	},
	status: data => {
		Channel.send('status', { status: data.data });
	},
	sticker: data => {
		sendMessage('sticker', Activity.current.room, `${data.group}-${data.seq}`);
	},
	w: data => {
		Channel.send('whisper', {
			rId: Activity.current.id,
			target: data.target,
			data: data.data
		});
	}
};
/**
 * 표준 하위 힌트 도출 함수를 생성한다.
 * 
 * @param {Function} poolBuilder 검색 배열을 생성시키는 함수
 * @param {Function} renderer 필터링된 결과에 대해 DOM 그리기 작업을 수행하는 함수
 * @returns {Function} 생성된 하위 힌트 도출 함수
 */
const CMD_STD_SUBHINT = function(poolBuilder, renderer){
	let my = this;

	this.styler = v => v.replace(this.data, `<label class="chint-match">${this.data}</label>`);
	return (data, argv) => {
		let R = "";
		let pool = poolBuilder();

		this.data = data;
		this.argv = argv;
		$data._subhint = pool.filter(v => v.indexOf(data) != -1);
		$data._subhint.forEach(v => R += `
		<div id="chint-sub-${v}" class="chint-sub-item chint-sub-list" onclick="onSubhintClick(this);">
			${renderer.call(my, v, this.styler)}
		</div>`);
		return R;
	};
};
/**
 * 명령어의 하위 힌트 도출 함수들을 포함하는 상수 객체이다.
 */
const CMD_SUBHINT = {
	set: [
		null,
		new CMD_STD_SUBHINT(
			() => OPT_KEYS,
			(v, styler) => `${styler(v)}: <label style="color: #AAA;">${
				L('optx-' + v).match(/<br\/>.+$/)[0].slice(5)
			}</label>`
		),
		true,
		(data, argv) => LANG['optx-' + argv[1]] ? `<div class="chint-sub-item chint-sub-list">
			<label class="chint-match">${argv[1]}</label><br/>
			${L('optx-' + argv[1])}<br/>
			<label style="color: gold;">${L('opts-current')}</label>: ${OPT[argv[1]]}<br/>
			<label style="color: orange;">${L('default')}</label>: ${OPT_DEFAULTS[argv[1]]}
		</div>` : ""
	],
	sticker: [
		null,
		new CMD_STD_SUBHINT(
			() => $data.myInfo.sticker.list.map(v => v.packCode),
			(v, styler) => `
				<img src="${STICKER_URL(v, 'tab_on', "type=m34_29")}" style="vertical-align: middle;"/> ${styler(v)}
			`
		),
		(data, argv) => {
			let R = "";
			let i, len = $data.myInfo.sticker.table[argv[1]];
			let preview = STICKER_URL(argv[1], 'preview', "type=p100_100");

			$data._subhint = [];
			for(i=0; i<len; i++){
				let x, y;
				
				if(data && String(i + 1).indexOf(data) == -1) continue;
				x = -108 * (i % 3);
				y = -100 * Math.floor(i / 3);
				$data._subhint.push(i + 1);
				R += `<div id="chint-sub-${i + 1}" class="chint-sub-item chint-sub-block chint-si-sticker"
					onclick="onSubhintClick(this);"
					style="background: url(${preview}) ${x}px ${y}px no-repeat;">
					${i + 1}
				</div>`;
			}
			return R;
		}
	],
	w: [
		null,
		new CMD_STD_SUBHINT(
			() => Activity.current.channel ? Activity.current.channel.list.map(v => v.id) : [],
			(v, styler) => styler(Activity.current.channel.$list.children(".actli-" + v).attr('title'))
		)
	]
};
const CMD_LIST = Object.keys(COMMANDS).sort();

CMD_SUBHINT['note'] = CMD_SUBHINT['call'] = CMD_SUBHINT['w'];
ipc.on('command', (ev, type, data) => COMMANDS[type](data));

function onSubhintClick(item){
	let value = item.id.slice(10);
	let argv;

	if($(item).hasClass("chint-si-sticker")){
		argv = $data._cmdText.split(' ');
		sendMessage('sticker', Activity.current.room, `${argv[1]}-${value}`);
		setCommandHint(false);
	}else{
		setCommandHint(true, $data._cmdText + value + " ");
	}
}
// 빠진 설정을 기본값으로 변경
(() => {
	let list = {};

	for(let i in OPT_DEFAULTS){
		if(!OPT.hasOwnProperty(i)) list[i] = OPT_DEFAULTS[i];
	}
	setOpt(list);
})();function onEvent(ev, type, data){
	switch(type){
		case 'login-ok':
			$data.myInfo = data;
			$stage.diag.loginOK.prop('disabled', false);
			notify(L('login-ok'));
			$dialog('login').hide();
			renderMyCafes();
			checkWatch();
			ipc.send('cojer', 'MyRoomList');
			break;
		case 'login-no':
			if(!data) data = {};
			$stage.diag.loginOK.prop('disabled', false);
			$stage.diag.loginOut.css('color', "red").html(data.text);
			notify(L('login-no'), data.text);
			if(data.captcha){
				$data._ckey = data.match(/key=(\w+)/)[1];
				$stage.diag.loginCaptcha.show();
			}else if(data.addDevice){
				$data._loginForm = {};
				$stage.diag.loginOut.css('color', "red")
					.append($("<label>").addClass("diag-label").html(L('error-121')))
					.append(data.addDevice);
				$stage.diag.loginOut.find("input[type=hidden]").each((i, o) => {
					$data._loginForm[o.name] = o.value;
				});
				$stage.diag.loginOut.find(".btn_upload>a").attr('onclick', "").on('click', e => {
					$data._loginForm['regyn'] = "Y";
					$stage.diag.loginOK.trigger('click');
				});
				$stage.diag.loginOut.find(".btn_cancel>a").attr('onclick', "").on('click', e => {
					$data._loginForm['regyn'] = "N";
					$stage.diag.loginOK.trigger('click');
				});
			}else if(data.otp){
				$data._loginForm = {};
				$stage.diag.loginOut.find("input[type=hidden]").each((i, o) => {
					$data._loginForm[o.name] = o.value;
				});
				$data._loginForm['otp'] = true;
				$stage.diag.loginOTP.show();
			}
			break;
		case 'logout':
			setOpt('auto');
			setOpt('channel-pw');
			alert(L('logout'));
			location.reload();
			break;
		case 'open-rooms':
			renderOpenRooms(data);
			break;
		case 'my-profile':
			data.id = $data.myInfo.id;
			$data.myInfo.profile[data.cId] = data;
			break;
		case 'my-rooms':
			renderMyRooms(data);
			if(localStorage.hasOwnProperty('recentAct')){
				setActivity(localStorage.getItem('recentAct'));
			}
			if(OPT['channel-pw']) Channel.init($data.myInfo.id, OPT['channel-pw']);
			break;
		case 'sess-msg':
			processMessage(data, false, true);
			break;
		case 'sess-err':
			console.error(data);
			break;
		case 'sess-progress':
			processProgress(data);
			break;
		case 'req-prev':
			Activity.current.$stage.prev.trigger('click');
			break;
		case 'prev-chat':
			data.reverse().forEach(v => processMessage(v, true));
			break;
		case 'chan-list':
			$stage.acts.toggleClass("channel-list-collapsed");
			break;
		case 'chat-image':
			Activity.current.$stage.board.find("img:last").trigger('click');
			break;
		case 'chat-time':
			$stage.acts.toggleClass("time-always-visible");
			break;
		case 'check-update':
			checkUpdate();
			break;
		case 'error':
			error(data.code, data.msg);
			break;
		case 'set-chat':
			Activity.current.$stage.chat.val(data.data);
			break;
		case 'watch-new':
			processWatch(data.cafe, JSON.parse(data.before), JSON.parse(data.after));
			break;
		case 'find':
			renderFindTable(data);
			break;
		case 'join':
			renderMyRooms([ data ], true);
			setActivity(data.id.replace(":", "-"));
			saveTabOrdinal();
			break;
		case 'quit':
			removeActivity(data.id.replace(":", "-"));
			saveTabOrdinal();
			break;
	}
}
ipc.on('event', onEvent);const FILTER_IMG = {
	filters: [{
		name: L('file-image'),
		extensions: [ 'jpg', 'png', 'gif' ]
	}],
	properties: [ "openFile" ]
};
const STATUS_CLASS = {
	'online': "online",
	'afk': "afk"
};
const USER_NOTICE = {
	id: "j-launcher",
	image: __dirname.replace(/\\/g, "/") + "/img/logo.ico",
	nickname: L('notice')
};
const CHANNEL_MENU = Remote.Menu.buildFromTemplate([
	{
		label: L('menu-actli-whisper'),
		click: () => { Activity.current.$stage.chat.val(`/w ${$data._cTarget} `).focus(); }
	},
	{
		label: L('menu-actli-note'),
		click: () => { Activity.current.$stage.chat.val(`/note ${$data._cTarget} `).focus(); }
	},
	{
		label: L('menu-actli-call'),
		click: () => Channel.callUser($data._cTarget)
	}
]);
const ACT_OPENED = "opened";

/**
 * 액티비티를 정의한다.
 * 각 액티비티는 방 목록 또는 한 채팅방을 담당하며 탭으로 전환시킬 수 있다.
 * 한 채팅방은 한 채널과 연관되어 있다.
 */
class Activity{
	/**
	 * @type {Activity}
	 * 현재 액티비티 객체를 가리킨다.
	 */
	static get current(){
		return $data.acts[$data.currentAct];
	}

	constructor(id, title, ord, $obj){
		this.id = id;
		this.title = title;
		this.ord = ord;
		this.history = new ChatHistory(this);
		this.$obj = $obj;
		
		this.$stage = {
			board: $obj.children(".act-board")
				.on('scroll', e => this.onBoardScroll(e.originalEvent)),
			ghost: $obj.find(".act-ghost").on('click', e => {
				let b = this.$stage.board.get(0);

				b.scrollTop = b.scrollHeight - b.clientHeight;
				$(e.currentTarget).hide();
			}),
			menu: $obj.children(".act-menu"),
			list: $obj.children(".act-list"),
			chat: $obj.find(".act-chat")
				.on('keydown', e => this.onChatKeyDown(e))
				.on('keyup', e => this.onChatKeyUp(e))
				.on('click', e => setCommandHint(false))
				.on('paste', e => this.onChatPaste(e.originalEvent)),
			send: $obj.find(".act-send")
				.on('click', e => this.onSendClick(e)),
			image: $obj.find(".act-image")
				.on('click', e => this.onImageClick(e)),
			sticker: $obj.find(".act-sticker")
				.on('click', e => this.onStickerClick(e)),
			prev: $obj.find(".act-menu-prev")
				.on('click', e => this.onMenuPrevClick(e)),
			save: $obj.find(".act-menu-save")
				.on('click', e => this.onMenuSaveClick(e)),
			find: $obj.find(".act-menu-find")
				.on('click', e => this.onMenuFindClick(e)),
			quit: $obj.find(".act-menu-quit")
				.on('click', e => this.onMenuQuitClick(e))
		};
		this.initChannel();
	}
	/**
	 * 채널을 초기화한다.
	 * 
	 * @param {*} $list 채널 이용자 목록을 가리키는 jQuery 객체(기본값: 액티비티 스테이지로부터 얻은 jQuery 객체)
	 */
	initChannel($list){
		if(this.id == ACT_OPENED) return;

		if(!$list) $list = this.$stage.list;
		if(OPT['channel-pw']){
			this.channel = new Channel(this.id, $list);
		}else{
			this.$stage.list.html(`
				<label>${L('act-mr-chan-no')}</label><br/>
				<button class="act-mr-chan-go-login" style="color: blue;">${L('act-mr-chan-go-login')}</button><br/>
				<button class="act-mr-chan-go-email" style="color: blue;">${L('act-mr-chan-go-email')}</button>
			`);
			this.$stage.list.children(".act-mr-chan-go-login").on('click', e => {
				prompt(L('act-mr-chan-go-login')).then(pw => {
					if(!pw) return;
					setOpt('channel-pw', pw);
					
					Channel.init($data.myInfo.id, pw);
					for(let i in $data.acts) $data.acts[i].initChannel();
				});
			});
			this.$stage.list.children(".act-mr-chan-go-email").on('click', e => {
				$.post(`http://${CHANNEL_HOST}/ncc/email`, { id: $data.myInfo.id }, res => {
					if(res) $dialog('ce', true).show().find("#diag-ce-target").html(L('diag-ce-target', $data.myInfo.id));
				});
			});
		}
	}
	/**
	 * 이 액티비티가 가지는 방 정보를 설정하고 방 정보에 맞게 DOM 객체를 수정한다.
	 * 
	 * @param {*} room 방 정보
	 */
	setRoom(room){
		this.room = room;
		this.nCount = 0;

		$(`#at-item-${this.id}`)[room.isPublic ? 'removeClass' : 'addClass']("at-item-locked");
		this.$stage.menu.children(".act-menu-title").html(`
			<label class="actm-title-name"><b>${room.name}</b></label><i/>
			<label class="actm-title-user">${L('act-mr-user', room.userCount)}</label><i/>
			<a class="actm-title-cafe" href="#" title="${L('visit-cafe')}" onclick="shell.openExternal('${CAFE_BOARD_URL(room.cafe.id)}');">${room.cafe.name}</a>
			<label class="actm-title-watch actm-tw-${room.cafe.id}" href="#" title="${L('act-mr-watch')}" onclick="toggleWatch(${room.cafe.id});">${FA('eye')}</label><i/>
			<label class="actm-title-attr">${room.isPublic ? L('act-mr-public') : L('act-mr-private')}</label>
		`);
	}
	/**
	 * 이 액티비티가 포함한 채팅 기록을 저장한다.
	 * 
	 * @param {string} path 기록될 파일의 경로
	 */
	requestSaveChat(path){
		let data = [];

		this.$stage.board.children(".act-talk").each((i, o) => {
			let $o = $(o);

			data.push(`[${$o.children(".actt-stamp").html()}] ${$o.children(".actt-user").attr('title')}: ${$o.children(".actt-body").html().trim()}`);
		});
		ipc.send('cojer', "Save", {
			path: path,
			data: data.join('\n')
		});
	}
	/**
	 * 이전 대화를 불러오도록 요청한다.
	 */
	requestPrevChat(){
		let v = this._prevChat;
		
		this._prevChat = Math.max(0, v - OPT['prev-per-req']);
		ipc.send('cojer', "PrevChat", {
			room: this.room,
			from: this._prevChat + 1,
			to: v
		});
	}
	/**
	 * 이 액티비티가 가리키는 방에서 퇴장한다.
	 */
	requestQuit(){
		ipc.send('cojer', "Quit", {
			room: this.room
		});
	}

	onBoardScroll(e){
		if(checkScrollBottom(e.currentTarget)) this.$stage.ghost.hide();
	}
	onChatKeyDown(e){
		switch(e.key){
			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '0':
				if(e.ctrlKey){
					this.$stage.chat.val(OPT['macro'][(Number(e.key) + 9) % 10]);
				}
				break;
			case '/':
				if(!e.currentTarget.value){
					$data._hint = true;
					setCommandHint(true, "/");
				}
				break;
			case 'Enter':
				if(!e.shiftKey){
					if($data._shIndex >= 0){
						let argv = this.$stage.chat.val().split(' ');

						argv[$data._cmdArgIndex] = $data._subhint[$data._shIndex];
						this.$stage.chat.val(argv.join(' ') + " ");
					}else if($data._hint && $data._hIndex >= 0){
						this.$stage.chat.val("/" + $data._hList[$data._hIndex] + " ");
					}else{
						this.$stage.send.trigger('click');
					}
					e.preventDefault();
				}
				break;
			case 'Escape':
				if($data._hint){
					setCommandHint(false);
				}else{
					this.$stage.ghost.hide();
				}
				break;
			case 'ArrowUp':
			case 'ArrowDown':
				this.onChatArrowUpDown(e);
				break;
			default: return;
		}
	}
	onChatArrowUpDown(e){
		if(!$data._hint){
			if(e.key == 'ArrowUp') Activity.current.history.up();
			else Activity.current.history.down();
			return;
		}
		let isSub = false;
		let iKey, iList;
		let vp;
		let di1, di2;
		
		if($data._subhint){
			isSub = true;
			iKey = '_shIndex';
			iList = '_subhint';
		}else{
			iKey = '_hIndex';
			iList = '_hList';
		}
		if($data[iKey] == -1){
			$data[iKey] = 0;
		}else{
			if(e.key == 'ArrowUp'){
				if(!$data[iKey]--) $data[iKey] = $data[iList].length - 1;
			}else{
				if(++$data[iKey] == $data[iList].length) $data[iKey] = 0;
			}
		}
		if(isSub){
			if($data._subhint[$data._shIndex] !== undefined){
				$(".chint-sub-item.chint-chosen").removeClass("chint-chosen");
				vp = $(`#chint-sub-${$data._subhint[$data._shIndex]}`).addClass("chint-chosen")[0].getBoundingClientRect();
			}
		}else{
			setCommandHint(true, e.currentTarget.value, $data[iList][$data[iKey]]);
			vp = $(".chint-chosen")[0].getBoundingClientRect();
		}
		di1 = window.innerHeight - this.$stage.chat.height() - vp.height - 10;
		di2 = di1 + vp.height - $stage.cmdHint.height();
		if(vp.top > di1) $stage.cmdHint[0].scrollTop += vp.top - di1;
		else if(vp.top < di2) $stage.cmdHint[0].scrollTop += vp.top - di2;
		
		e.preventDefault();
	}
	onChatKeyUp(e){
		if($data._hint){
			if(e.key == 'ArrowUp' || e.key == 'ArrowDown') return;
			$data._hIndex = -1;
			setCommandHint(true, e.currentTarget.value);
		}
	}
	onChatPaste(e){
		let files, len, i;

		switch(e.type){
			case "drop":
				files = e.dataTransfer.files;
				len = files.length;
				if(!len || files[0].kind == "string") return true;

				$data._uploading = files[0].path.replace(/\\/g, "/");
				$dialog('upload', true).show();
				$stage.diag.uploadImg.attr('src', $data._uploading);
				if(OPT['no-ask-upload']) $stage.diag.uploadOK.trigger('click');
				break;
			case "paste":
				files = e.clipboardData.items;
				len = files.length;
				if(!len || files[len - 1].kind == "string") return true;

				$data._uploading = Clipboard.readImage();
				$dialog('upload', true).show();
				$stage.diag.uploadImg.attr('src', $data._uploading.toDataURL());
				$data._uploading = $data._uploading.toPNG();
				if(OPT['no-ask-upload']) $stage.diag.uploadOK.trigger('click');
				break;
		}
		return false;
	}
	onSendClick(e){
		let text = this.$stage.chat.val();

		if(text.length > 500) if(!confirm(L('error-101'))){
			return this.$stage.chat.val(text.slice(0, 500));
		}
		sendMessage("text", this.room, text);
		setCommandHint(false);
		this.$stage.chat.val("");
	}
	onImageClick(e){
		Remote.dialog.showOpenDialog(Remote.getCurrentWindow(), FILTER_IMG, files => {
			if(!files) return;
			files.forEach(v => sendMessage('image', this.room, v));
		});
	}
	onStickerClick(e){
		setCommandHint(true, "/sticker ");
	}
	onMenuPrevClick(e){
		this.$stage.prev.prop('disabled', true);
		setTimeout(() => this.$stage.prev.prop('disabled', false), 1000);

		this.requestPrevChat();
	}
	onMenuSaveClick(e){
		Remote.dialog.showSaveDialog(Remote.getCurrentWindow(), {
			title: L('act-mr-save'),
			defaultPath: `${this.room.name}-${Date.now()}.txt`
		}, path => path && this.requestSaveChat(path.replace(/\\/g, "/")));
	}
	onMenuFindClick(e){
		$dialog('find', true).show();
	}
	onMenuQuitClick(e){
		if(!confirm(L('sure-quit', this.room.name))) return;

		this.requestQuit();
	}
}

/**
 * 채널을 정의한다.
 * 채널에 접속하여 쪼런처를 이용하는 사람들에게 부가 기능을 제공한다.
 */
class Channel{
	/**
	 * 주어진 인증 정보로 채널 접속을 시도한다.
	 * 접속에 성공하는 경우 Channel 클래스의 정적 멤버 socket을 통해 통신할 수 있다.
	 * 
	 * @param {string} id 네이버 아이디
	 * @param {string} pw 채널 암호
	 */
	static init(id, pw){
		let socket = new WebSocket(`ws://${CHANNEL_HOST}:525/${id}@${pw}`);
		
		if(Channel.socket){
			Channel._queue = [];
			Channel.socket.onmessage = undefined;
			Channel.socket.onclose = undefined;
			Channel.socket.close();
			delete Channel.socket;
		}
		socket.onmessage = Channel.onMessage;
		socket.onclose = Channel.onClose;
	}
	/**
	 * 채널로 정보를 전송한다.
	 * 채널에 접속한 상태가 아닌 경우 큐에 정보를 저장한다.
	 * 
	 * @param {string} type 정보의 유형
	 * @param {string} data 정보
	 */
	static send(type, data){
		if(!data) data = {};
		data.type = type;
		data = JSON.stringify(data);

		if(Channel.socket) Channel.socket.send(data);
		else Channel._queue.push(data);
	}
	/**
	 * send() 메소드 등에 의해 큐에 저장된 정보를 즉시 채널로 전송하고 큐를 비운다.
	 * 
	 * @param {WebSocket} socket 웹소켓 객체
	 */
	static flushQueue(socket){
		Channel.socket = socket;
		while(Channel._queue[0]) socket.send(Channel._queue.shift());
	}
	/**
	 * 채널에 접속해 있는 해당 아이디를 가진 사용자를 호출한다.
	 * 
	 * @param {string} id 네이버 아이디
	 * @param {string} rId 채팅방 식별자(기본값: 현재 채팅방 식별자)
	 */
	static callUser(id, rId){
		log(L('sent-call', id));
		Channel.send('call', {
			rId: rId || Activity.current.room.id,
			target: id
		});
	}
	/**
	 * 주어진 정보를 바탕으로 사용자 정보를 갱신한다.
	 * 
	 * @param {*} user 사용자 정보
	 */
	static updateUser(user){
		let $items = $(`.actli-${user.id}`);
		let status = global.LANG[`diag-status-${user.status}`] || user.status;
		let title = `${user.nickname} (${user.id})\n${status}`;

		$items.attr('title', title);
		$items.children(".act-list-item-status")
			.removeClass("actli-status-online actli-status-custom actli-status-afk")
			.addClass(`actli-status-${STATUS_CLASS[user.status] || 'custom'}`);
		$items.find(".act-list-item-nick").html(user.nickname);
		$items.children(".act-list-item-exordial").html(user.exordial);
	}
	static onMessage(e){
		let data = JSON.parse(e.data);
		let chan = ($data.acts[data.rId] || {}).channel;

		switch(data.type){
			case 'welcome':
				Channel.flushQueue(e.target);
				break;
			case 'error':
				error(data.code, data.msg);
				break;
			case 'conn':
				if(!OPT['optx-no-channel-notice']) log(L('chan-conn', data.user.nickname), chan.rId);
				chan.list.push(data.user);
				chan.renderList();
				break;
			case 'disconn':
				if(!OPT['optx-no-channel-notice']) log(L('chan-disconn', data.user.nickname), chan.rId);
				chan.list = chan.list.filter(v => v.id != data.user.id);
				chan.renderList();
				break;
			case 'list':
				chan.list = data.list;
				chan.renderList();
				break;
			case 'notes':
				processNotes(data);
				break;
			case 'user':
				Channel.updateUser(data.user);
				break;
			case 'whisper':
				processWhisper(data);
				break;
			default:
				console.warn("Unhandled data: ", data);
		}
	}
	static onClose(code){
		setOpt('channel-pw');
		$(".act-list").addClass("act-list-closed").html(`
			<label>${L('act-mr-chan-closed')}</label><br/>
			<button style="color: blue;" onclick="Activity.current.initChannel();">${L('act-mr-chan-retry')}</button>
		`);
	}

	constructor(rId, $list){
		this.rId = rId;
		this.$list = $list;
		this.list = [];

		Channel.send('join', { rId: rId });
	}
	renderList(){
		this.$list.removeClass("act-list-closed").empty();
		this.list.forEach(v => {
			let $item;

			this.$list.append($item = $(`
				<div id="actli-${this.rId}-${v.id}" class="act-list-item actli-${v.id}">
					<div class="act-list-item-status"/>
					<div class="act-list-item-name ellipse">
						<label class="act-list-item-nick"/>
						<label class="act-list-item-id"> (${v.id})</label>
					</div>
					<div class="act-list-item-exordial ellipse"/>
				</div>
			`.trim()));
			Channel.updateUser(v);
			$item.on('click', this.onClick).on('contextmenu', this.onClick);
			if(v.id == $data.myInfo.id) $item.addClass("act-list-item-me");
		});
	}
	onClick(e){
		$data._cTarget = e.currentTarget.id.split('-')[3];
		CHANNEL_MENU.popup(Remote.getCurrentWindow());
	}
	close(){
		Channel.send('leave', { rId: this.rId });
	}
}
Channel._queue = [];

/**
 * 채팅 내역을 정의한다.
 * 사용자의 키 입력에 따라 내역을 조회할 수 있다.
 */
class ChatHistory{
	constructor(activity){
		this.activity = activity;
		this.list = [];
		this.index = -1;
		this.lastChat = null;
	}

	/**
	 * 입력 내역에 주어진 내용을 추가한다.
	 * 
	 * @param {string} data 내용
	 */
	put(data){
		if(this.list.unshift(data) > OPT['history-max']){
			this.list.pop();
		}
		this.index = -1;
		this.lastChat = null;
	}

	/**
	 * 내역을 위로 하나 탐색하여 연결된 액티비티의 입력란에 넣는다.
	 */
	up(){
		let chat = this.activity.$stage.chat[0];
		let len = this.list.length;

		if(chat.selectionStart + chat.selectionEnd > 0) return;
		if(!len) return;
		if(this.index == -1) this.lastChat = chat.value;

		this.index = Math.min(this.index + 1, len - 1);
		chat.value = this.list[this.index];
	}

	/**
	 * 내역을 아래로 하나 탐색하여 연결된 액티비티의 입력란에 넣는다.
	 */
	down(){
		let chat = this.activity.$stage.chat[0];

		if(this.index == 0 && this.lastChat){
			chat.value = this.lastChat;
			return;
		}
		if(chat.selectionStart != chat.selectionEnd || chat.selectionEnd != chat.value.length) return;
		if(!this.list.length) return;

		this.index = Math.max(this.index - 1, 0);
		chat.value = this.list[this.index];
	}
}/**
 * 명령어 사용에 대한 메시지를 출력한다.
 * 
 * @param {string} msg 메시지
 * @param {string} rId 출력할 채팅방 식별자(기본값: 현재 채팅방)
 * @param {string} group 채팅 jQuery 객체에 부가적으로 넣을 클래스의 접미어(기본값: 없음)
 * @param {string} addPre 기본 접두어에서 부가적으로 넣을 접두어(기본값: 없음)
 * @returns {*} 새로 생성된 채팅 jQuery 객체
 */
function command(msg, rId, group, addPre){
	let user = (group == "cmd-send") ? null : USER_NOTICE;
	let $R = emulateMessage("command", msg, `<label style="color: gray;">${FA('gear')}</label>${addPre || " "}`, rId, user);

	if(group) $R.addClass(`act-talk-${group}`);
	return $R;
}
/**
 * 채팅방에 로그를 출력한다.
 * 
 * @param {string} msg 메시지
 * @param {string} rId 출력할 채팅방 식별자(기본값: 현재 채팅방)
 */
function log(msg, rId){
	let $R = emulateMessage("command", msg, `<label style="color: deepskyblue;">${FA('info-circle', true)}</label>`, rId, USER_NOTICE);

	return $R;
}
/**
 * 업데이트를 확인하고 필요에 따라 안내 대화 상자를 띄운다.
 */
function checkUpdate(){
	$.get(LATEST_VERSION_URL, res => {
		if(res.tag_name == VER){
			return log(L('latest-version'));
		}
		notice(L('diag-notice-latest-head', res.tag_name), JOM.parse(res.body), e => {
			shell.openExternal(res.html_url);
			$dialog('notice').hide();
		});
	});
}
/**
 * 구독한 카페의 새 글을 확인하고 필요에 따라 알린다.
 */
function checkWatch(){
	ipc.send('cojer', 'Watch', {
		cafeList: OPT['watch-list'],
		urlList: OPT['watch-list'].map(CAFE_BOARD_URL)
	});
	if(OPT['watch-interval'] >= 1) $data._watchT = setTimeout(checkWatch, OPT['watch-interval'] * 60000);
}
/**
 * 카페를 구독하거나 구독 취소한다.
 * 일정 주기마다 구독한 카페의 새 글을 자동으로 확인한다.
 * 
 * @param {number} id 카페 식별자
 */
function toggleWatch(id){
	let list = OPT['watch-list'];
	let seq = list.indexOf(id);

	if(seq == -1) list.push(id);
	else list.splice(seq, 1);

	setOpt('watch-list', list);
	renderWatch();
}
/**
 * 카페의 구독 여부 표시를 갱신한다.
 */
function renderWatch(){
	$(".actm-title-watching").removeClass("actm-title-watching");
	OPT['watch-list'].forEach(v => {
		$(".actm-tw-" + v).addClass("actm-title-watching");
	});
}
/**
 * 게시글 정보를 비교하여 필요에 따라 알린다.
 * 
 * @param {number} cafe 카페 식별자
 * @param {any[]} before 이전 게시글 정보
 * @param {any[]} after 현재 게시글 정보
 */
function processWatch(cafe, before, after){
	let i, cafeName;
	let diff = [];
	let bLast = before[0];
	let aLast = after[0];
	let title, text;

	for(i in $data.myInfo.cafeList) if($data.myInfo.cafeList[i].id == cafe){
		cafeName = $data.myInfo.cafeList[i].name;
	}
	for(i in after){
		if(bLast.id < after[i].id) diff.push(after[i]);
	}
	title = L('watch-new', cafeName);
	if(diff.length > 1){
		text = L('watch-new-many', aLast.author, aLast.title, diff.length);
	}else if(diff.length){
		text = L('watch-new-one', aLast.author, aLast.title);
	}
	notify(title, text);
	$(".actm-tw-" + cafe).each((i, o) => {
		emulateMessage('watch', text,
			`<label style="color: dodgerblue;">${FA('eye')}</label>
			[<a href="#" onclick="shell.openExternal('${CAFE_ARTICLE_URL(cafe, aLast.id)}');">${L('go')}</a>]&nbsp;`,
			$(o).parents(".activity").attr('id').slice(4)
		, USER_NOTICE, null, true);
	});
}
/**
 * 주어진 방에서 채팅을 검색한다.
 * 
 * @param {string} word 검색어
 * @param {object} opts 검색 옵션{ regex: 진릿값, last: 검색 범위 출발 지점 }
 * @param {string} rId 채팅방 식별자(기본값: 현재 채팅방)
 */
function findChatting(word, opts, rId){
	let act = rId ? $data.acts[rId] : Activity.current;

	if(!opts) opts = {};
	ipc.send('cojer', 'Find', {
		word: word,
		opts: opts,
		room: act.room,
		last: opts.last || act._lastMsgId || act.room.lastMsgSn
	});
}
/**
 * 검색 결과 표를 갱신한다.
 * 
 * @param {object} data 검색 결과 정보
 */
function renderFindTable(data){
	let word = data.word;
	let $table = $stage.diag.find.table.empty();
	let dateRange = data.dateRange.map(v => new Date(v));

	$stage.diag.find.msgid.val($data._findLast = data.last);
	if(!dateRange.length) return $table.html(L('diag-find-no-res'));
	if(data.opts.regex) word = new RegExp(word);
	$stage.diag.find.status.html(L('diag-find-result', data.list.length,
		dateRange[0].toLocaleString(),
		dateRange[1].toLocaleString(),
		data.length
	));
	data.list.forEach((v, i) => {
		let cssContext = v.context.replace(word, w => `<label style="color: cornflowerblue;">${w}</label>`);

		$table.append(`<div id="diag-find-ti-${v.id}" class="diag-find-table-item" title="${v.context}">
			<div class="diag-find-ti-number">${i + 1}</div>
			<div class="diag-find-ti-context ellipse">${cssContext}</div>
			<div class="diag-find-ti-time">${new Date(v.time).toLocaleTimeString()}</div>
		</div>`);
	});
	$table.children(".diag-find-table-item").on('click', e => {
		let destId = Number(e.currentTarget.id.slice(13));
		let rId = data.rId.replace(":", "-");
		let act = $data.acts[rId];

		act.$stage.board.empty();
		ipc.send('cojer', 'PrevChat', {
			room: act.room,
			from: destId - 49,
			to: destId + 50
		});
		log(L('find-result'), rId);
	});
}
/**
 * 새 액티비티를 생성하고 탭을 갱신한다.
 * 
 * @param {string} id 액티비티 식별자 
 * @param {string} title 탭 제목
 * @param {*} $obj 액티비티 내용. 이 함수 내에서는 생성되는 액티비티 자체로 취급한다.
 * @returns {Activity} 생성된 액티비티
 */
function createActivity(id, title, $obj){
	let ord = $data.tabOrdinal[`at-item-${id}`] || Object.keys($data.acts).length;

	$stage.acts.append($obj = $(`<div id="act-${id}" class="activity">`).html($obj));
	$data.acts[id] = new Activity(id, title, ord, $obj);

	renderActTab();
	return $data.acts[id];
}
/**
 * 해당 액티비티를 목록에서 제외시키고 탭을 갱신한다.
 * 
 * @param {string} id 액티비티 식별자
 */
function removeActivity(id){
	$(`#act-${id}`).remove();
	if($data.acts[id].channel) $data.acts[id].channel.close();
	delete $data.acts[id];
	if($data.currentAct == id) setActivity(ACT_OPENED);

	renderActTab();
}
/**
 * 현재 액티비티를 설정한다.
 * 
 * @param {string} id 액티비티 식별자
 */
function setActivity(id){
	let cr;

	$data.currentAct = id;
	localStorage.setItem('recentAct', id);
	$(".act-talk-last").remove();
	if(Activity.current && Activity.current.nCount > 0){
		$(`#actt-${id}-${Activity.current.nStartId}`).before(`<div class="act-talk act-talk-last"/>`);
		Activity.current.nCount = 0;
	}
	$(".at-current").removeClass("at-current");
	$(`#at-item-${id}`).removeClass("at-notify").addClass("at-current")
		.children(".ati-count").hide();
	$(".activity").hide();
	$(`#act-${id}`).show();
	if(id != ACT_OPENED && (cr = Activity.current.room)){
		if(!Activity.current.hasOwnProperty('_prevChat') && cr.lastMsgSn > 0){
			Activity.current._prevChat = cr.lastMsgSn;
			Activity.current.requestPrevChat();
		}
	}
	Activity.current.$stage.chat.focus();
}
/**
 * 탭을 갱신한다. 현재 생성된 액티비티가 나타난다.
 */
function renderActTab(){
	let list = Object.keys($data.acts);
	let $wrapper = $("<div>").attr('id', "at-wrapper");
	let wrapperWidth = 0;

	$stage.actTab.empty().off('wheel').on('wheel', onWheel).append($wrapper);
	list.map(v => $data.acts[v]).sort((a, b) => a.ord - b.ord).forEach(v => {
		let $item;

		$wrapper.append($item = $(`
			<div id="at-item-${v.id}" class="at-item ellipse${(v.room && !v.room.isPublic) ? " at-item-locked" : ""}" draggable="true" onclick="setActivity('${v.id}');">
				<label class="ati-count" style="display: none;"></label>
				<i class="fa fa-lock ati-locked"/>
				<label>${v.title}</label>
			</div>
		`.trim())
			.on('dragstart', onTabDragStart)
			.on('dragenter', onTabDragEnter)
			.on('dragend', onTabDragEnd)
		);
		wrapperWidth += $item[0].getBoundingClientRect().width + 1;
	});
	$wrapper.width(wrapperWidth);

	function onTabDragStart(e){
		$data._movingTab = $(e.currentTarget);
		$stage.actTab.on('dragenter', onTabDragEnter);

		e.originalEvent.dataTransfer.setData('text/plain', e.currentTarget.id);
	}
	function onTabDragEnter(e){
		let $t = $(e.originalEvent.target);
		let tId = $t.attr('id');

		if(tId == "act-tab" || tId == "at-wrapper"){
			$t.find(".at-item:last-child").after($data._movingTab);
		}else{
			$t.before($data._movingTab);
		}
	}
	function onTabDragEnd(e){
		saveTabOrdinal();
		delete $data._movingTab;
		$stage.actTab.off('dragenter', onTabDragEnter);
	}
	function onWheel(e){
		let delta = e.originalEvent.deltaX || e.originalEvent.deltaY;

		$wrapper.css('left', Math.min(0, Math.max(-wrapperWidth + window.innerWidth, $wrapper.position().left - delta)));
	}
	$(`#at-item-${$data.currentAct}`).addClass("at-current");
}
/**
 * 탭 순서 정보를 저장한다.
 */
function saveTabOrdinal(){
	let ord = [];
	
	$stage.actTab.find(".at-item").each((i, o) => ord.push(o.id));
	localStorage.setItem('tab-ordinal', ord.join(','));
	loadTabOrdinal();
}
/**
 * 탭 순서 정보를 불러온다.
 */
function loadTabOrdinal(){
	let ord = localStorage.getItem('tab-ordinal');

	if(ord) ord = ord.split(',');
	else ord = [];

	$data.tabOrdinal = {};
	ord.map((v, i) => $data.tabOrdinal[v] = i);
}
/**
 * 카페 목록을 갱신한다.
 */
function renderMyCafes(){
	$stage.cafeList.empty().append(`<option>${L('act-or-cafe-select')}</option>`);
	$data.myInfo.cafeList.forEach((v, i) => {
		$stage.cafeList.append(`<option value="${i}">${v.name}</option>`);
	});
}
/**
 * 선택된 카페에서 공개된 채팅방들의 목록을 갱신한다.
 * 
 * @param {any[]} list 공개된 채팅방 목록
 */
function renderOpenRooms(list){
	let now = Date.now();

	$stage.roomList.empty();
	$(".act-or-cm-count").html(L('act-or-room-count', list.length));
	list.forEach(v => {
		let id = v.id.replace(":", "-");
		let u = (now - new Date(v.updated).getTime()) * 0.001;

		if(u < 60) u = L('act-or-room-time-sec');
		else if(u < 3600) u = L('act-or-room-time-min', Math.round(u / 60));
		else if(u < 86400) u = L('act-or-room-time-hour', Math.round(u / 3600));
		else u = L('act-or-room-time-day', Math.round(u / 86400));

		$stage.roomList.append(`
			<div id="act-or-room-${id}" class="act-or-room" onclick="requestJoin('${$data.currentCafe.id}', '${v.id}');">
				<div class="acto-room-name"><b>${v.name}</b></div>
				<div class="acto-room-user">${L('act-mr-user', v.userCount)}</div>
				<div class="acto-room-attr">${v.isPublic ? L('act-mr-public') : L('act-mr-private')}</div>
				<div class="acto-room-time">${u}</div>
			</div>
		`);
	});
}
/**
 * 내 채팅방들을 각각 액티비티로 취급하여 생성한다. 이 함수는 중복 검사를 하지 않는다.
 * 
 * @param {any[]} list 내 채팅방 목록
 * @param {boolean} prevAble true인 경우 자동으로 이전 채팅 기록을 불러오지 않는다.
 */
function renderMyRooms(list, noPrev){
	list.forEach(v => {
		let act = createActivity(v.id.replace(":", "-"), v.name, `
			<div class="act-menu">
				<div class="act-menu-title ellipse"></div>
				<button class="act-menu-quit" title="${L('act-mr-quit')}">${FA('sign-out')}</button>
				<button class="act-menu-prev" title="${L('act-mr-prev')}">${FA('backward')}</button>
				<button class="act-menu-save" title="${L('act-mr-save')}">${FA('download')}</button>
				<button class="act-menu-find" title="${L('act-mr-find')}">${FA('search')}</button>
			</div>
			<div class="act-board"></div>
			<div class="act-list act-list-closed"></div>
			<div class="act-ghost act-talk"></div>
			<div class="act-me">
				<textarea class="act-chat"></textarea>
				<button class="act-send">${L('act-mr-send')}</button>
				<button class="act-image">${L('act-mr-image')}</button>
				<button class="act-sticker">${L('act-mr-sticker')}</button>
			</div>
		`);
		if(noPrev) act._prevChat = 0;
		act.setRoom(v);
	});
	renderWatch();
}
/**
 * 주어진 DOM 객체의 스크롤이 가장 아래에 있는지 확인한다.
 * 
 * @param {HTMLElement} obj DOM 객체
 * @returns {boolean} true인 경우 스크롤이 가장 아래에 있는 상태이다.
 */
function checkScrollBottom(obj){
	return obj.scrollHeight - obj.scrollTop - obj.clientHeight < 1;
}
/**
 * 세션에서 받은 정보를 처리한다.
 * 
 * @param {*} data 받은 정보
 * @param {boolean} prev 이전 채팅 여부. true인 경우 가장 위에 배치된다.
 * @param {boolean} saveId true인 경우 대상 액티비티의 최근 메시지 번호가 이 정보의 번호로 설정된다.
 * @param {boolean} silent true인 경우 대화 카운트를 올리지 않는다.
 * @returns {*} 새로 생성된 채팅 jQuery 객체
 */
function processMessage(data, prev, saveId, silent){
	let rId = data.room.id.replace(":", "-");
	let act = $data.acts[rId];
	let profile = $data.myInfo.profile[act.room.cafe.id] || USER_NOTICE;
	if(!act){
		// 일대일 채팅이 생겼을 때 방 정보가 나타나지 않는 경우에 대한 처리
		if(!data.room.name){
			data.room.name = data.user.nickname;
			data.room.userCount = 2;
		}
		renderMyRooms([ data.room ], true);
		act = $data.acts[rId];
	}
	let $board = act.$stage.board, board = $board.get(0);
	let isMe = data.user.id == $data.myInfo.id;
	let isWhite = false;
	let isBottom = checkScrollBottom(board);
	let now = new Date(data.time);
	let $talk;
	let content = `${data.user.id}: ${data.message}`;

	if(isMe) data.user = profile;
	else{
		if(checkBW(OPT['white'], content)){
			isWhite = true;
			if(!prev) notify(L('on-white', data.user.nickname), data.message);
		}
		if(checkBW(OPT['black'], content)){
			if(!prev) ipc.send('black', {
				id: data.user.id,
				content: data.message,
				time: now
			});
			return;
		}
	}
	if(OPT['no-image']) data.type = "text";

	switch(data.type){
		case "text": content = `
			${cUser(data.user)}
			<div class="actt-body">${data.preMessage || ''}${produceText(data.message)}</div>
			`;
			break;
		case "image": content = `
			${cUser(data.user)}
			<div class="actt-body">
				<img src="${data.thumb || (data.image + "?type=w128")}" onerror="$(this).replaceWith(FA('exclamation-circle'));" onload="processImage(this, '${data.image}', ${isBottom});"/>
			</div>
			`;
			break;
		case "sticker":
			if(!data.image){
				data._sticker = data.message.split('-');
				data._sticker = STICKER_URL(data._sticker[0], data._sticker[1]);
				data.xxhdpi = data._sticker + "?type=p100_100";
				data.image = data._sticker + "?type=p50_50";
			}
			content = `
			${cUser(data.user)}
			<div class="actt-body">
				<img src="${data.image}" title="${data.image}" onerror="$(this).replaceWith(FA('exclamation-circle'));" onload="processImage(this, '${data.xxhdpi}', ${isBottom});"/>
			</div>
			`;
			break;
		case "join": // 입장
		case "leave": // 퇴장
			content = cNotice(data.type,
				data.user.nickname, data.user.id
			);
			act.setRoom(data.room);
			renderWatch();
			break;
		case "invite": // 초대
			content = cNotice(data.type,
				data.user.nickname, data.user.id,
				data.target.map(v => `${v.nickname} (${v.id})`).join(', ')
			);
			act.setRoom(data.room);
			renderWatch();
			break;
		case "reject": // 강퇴
			content = cNotice(data.type,
				data.user.nickname, data.user.id,
				data.target.nickname, data.target.id
			);
			act.setRoom(data.room);
			renderWatch();
			break;
		case "changeMaster": // 방장
			content = cNotice("change-master",
				data.target
			);
			act.setRoom(data.room);
			renderWatch();
			break;
		case "changeName": // 방 제목
			content = cNotice("change-name",
				data.user.nickname, data.user.id,
				data.target
			);
			act.setRoom(data.room);
			renderWatch();
			break;
		default:
			console.log(data);
	}
	$board[prev ? 'prepend' : 'append']($talk = $(`<div id="actt-${rId}-${data.id}" class="act-talk act-talk-${data.user.id}">
		${content}
		<div class="actt-stamp" title="${now.toLocaleString()}">${now.toLocaleTimeString()}</div>
	</div>`));
	$talk.on('click', e => {
		if(e.target.tagName == "IMG" || e.target.tagName == "A") return;
		traceMessage(data.user.id);
	});
	if(!silent && $data.currentAct != rId){
		if(act.nCount === 0) act.nStartId = data.id;
		$(`#at-item-${rId}`).addClass("at-notify")
			.children(".ati-count").show().html(++act.nCount);
	}
	if(!OPT['no-trace'] && $data._traced == data.user.id) $talk.addClass("act-talk-traced");
	if(isMe){
		$talk.addClass("act-my-talk");
		if($data._$pending){
			$data._$pending.remove();
			delete $data._$pending;
		}
	}else if(isWhite){
		$talk.addClass("act-white-talk");
	}
	if(isBottom || isMe){
		board.scrollTop = board.scrollHeight - board.clientHeight;
	}else if(!prev){
		act.$stage.ghost.show().html($talk.html());
	}
	if(!prev && board.children.length > OPT['max-chat']){
		act._prevChat++;
		board.removeChild(board.children[0]);
	}
	if(saveId) act._lastMsgId = data.id;
	playSound('k');

	function cUser(user){
		return `
			<div class="actt-user ellipse" title="${user.nickname} (${user.id})">
				<div class="actt-user-image" style="background-image: url(${user.image});"/>
				${user.nickname}
			</div>
		`;
	}
	function cNotice(type, ...args){
		args.unshift("notice-" + type);

		return `<div class="actt-notice">${L.apply(this, args)}</div>`;
	}
	return $talk;
}
/**
 * 메시지 출력을 모방한다.
 * 
 * @param {string} type 모방 유형 식별자
 * @param {string} msg 메시지(기본값: "")
 * @param {string} pre 전(pre)-메시지(기본값: "")
 * @param {string} rId 채팅방 식별자(기본값: 현재 채팅방)
 * @param {*} user 사용자 정보(기본값: 내 정보)
 * @param {number} time 시간 정보(기본값: 현재)
 * @param {boolean} silent true인 경우 대화 카운트를 올리지 않는다.
 * @returns {*} 새로 생성된 채팅 jQuery 객체
 */
function emulateMessage(type, msg, pre, rId, user, time, silent){
	let cafeId = rId ? $data.acts[rId.replace(":", "-")].room.cafe.id : Activity.current.room.cafe.id;

	return processMessage({
		id: `${type}-${++$data.localId}`,
		room: { id: rId || Activity.current.room.id },
		user: user || $data.myInfo.profile[cafeId] || USER_NOTICE,
		type: "text",
		preMessage: pre || "",
		message: msg,
		time: time || Date.now()
	}, false, false, silent);
}
/**
 * 채널로부터의 쪽지를 처리한다.
 * 
 * @param {*} data 쪽지 정보
 */
function processNotes(data){
	let pre = `<label style="color: skyblue;">${FA('envelope')}</label> `;

	data.list.forEach(v => {
		emulateMessage("notes", v.data, pre, undefined, v.from, v.time);
	});
}
/**
 * 진행 이벤트를 처리한다.
 * 파일 업로드 등에서 진행 이벤트가 발생한다.
 * 
 * @param {*} data 진행 이벤트 정보
 */
function processProgress(data){
	if(!$data._$pending) return;
	$data._$pending.children(".actt-body").html(data.percent.toFixed(1) + "%");
}
/**
 * 채널로부터의 귓속말을 처리한다.
 * 
 * @param {*} data 귓속말 정보
 */
function processWhisper(data){
	let $window = Remote.getCurrentWindow();
	let pre = `<label style="color: orange;">${FA('lock')}</label> `;
	let $talk;
	let notiTitle;
	
	if(data.data === true){ // 호출
		pre = pre.replace(FA('lock'), FA('feed'));
		notiTitle = data.data = L('on-call', data.from.nickname);
		playSound('alarm');
	}else if(data.data === 1){ // 쪽지 보내기에 성공
		pre = pre.replace(FA('lock'), FA('envelope'));
		data.data = L('noted');
		notiTitle = null;
	}else{
		notiTitle = L('on-whisper', data.from.nickname);
	}
	$talk = emulateMessage('whisper', data.data, pre, data.rId, data.from)
		.addClass("act-talk-cmd-receive");

	if(notiTitle) if(!$window.isFocused() || $window.isMinimized()) notify(notiTitle, data.data);
}
/**
 * 불러온 이미지 정보를 처리한다.
 * 
 * @param {HTMLImageElement} img 이미지 DOM 객체
 * @param {string} source 원본 이미지 경로
 * @param {boolean} downScroll 스크롤 내리기 여부. true인 경우 이미지의 높이만큼 스크롤을 내린다.
 */
function processImage(img, source, downScroll){
	let $img = $(img).on('click', e => popupImage(source));

	if(downScroll) $img.parent().parent().parent().get(0).scrollTop += img.height;
}
/**
 * 불러온 텍스트 정보를 가공한다.
 * 
 * @param {string} text 텍스트
 * @returns {string} 가공된 텍스트
 */
function produceText(text){
	const TABLE = {
		'<': "&lt;", '>': "&gt;", '&': "&amp;", '\n': "<br>", ' ': "&nbsp;"
	};
	let R;
	
	if(OPT['use-jom']) R = JOM.parse(text
		.replace(/ /g, "&nbsp;")
		.replace(/\n/g, "\n\n")
		.replace(/(https?:\/\/.+?\.[^)]+?)(?:&nbsp;|\s|<br>|$)/gi, (v, p1) => `[${p1}](${p1})`));
	else R = text
		.replace(/<|>|&|\n| /g, v => TABLE[v])
		.replace(/(https?:\/\/.+?\..+?)(?:&nbsp;|\s|<br>|$)/gi, (v, p1) => `<a href="#" onclick="shell.openExternal('${p1}');">${p1}</a>`);
	
	if(OPT['youtube-view']) R = R
		.replace(/<a\s+.+?onclick="shell\.openExternal\('https:\/\/(?:\w+?\.youtube\.com\/watch\?v=|youtu\.be\/)(.+?)(?:&.+)?'\);".*?>.+?<\/a>/g, (v, p1) => `${v}<iframe src="https://www.youtube.com/embed/${p1}" allowfullscreen frameborder="0"></iframe>`);

	return R;
}
/**
 * 주어진 명령어의 한 인자에 대한 하위 힌트를 가공한다.
 * 
 * @param {string} cmd 명령어
 * @param {number} index 인자 번호(0은 명령어)
 * @param {string} value 현재 인자 값
 * @param {string[]} argv 전체 명령어 배열
 * @returns {string} 가공된 하위 힌트
 */
function produceSubhint(cmd, index, value, argv){
	let lister = CMD_SUBHINT[cmd];
	let len;
	let R = "";

	$data._cmdArgIndex = index;
	if(!lister) return "";
	len = lister.length;
	if(lister[len - 2] === true && index >= len - 2) index = len - 1;
	if(!lister[index]) return "";

	return lister[index](value, argv);
}
/**
 * 메시지를 전송한다.
 * 전송하려는 메시지는 현재 DOM의 상황에 따라 자동적으로 결정된다.
 * 
 * @param {string} type 정보 유형(다음 중 하나: text, image, sticker)
 * @param {*} room 보낼 채팅방 객체
 * @param {*} data 보낼 정보
 */
function sendMessage(type, room, data){
	if(!data) return;

	if(type == "text"){
		Activity.current.history.put(data);
		// 명령어 처리
		if(data[0] == '/'){
			let ci = data.indexOf(' ');
			let form;
			
			if(ci == -1) ci = data.length;
			form = {
				type: data.slice(1, ci),
				room: room,
				raw: data,
				data: data.slice(ci + 1)
			};
			command(form.raw, form.room.id, 'cmd-send');
			ipc.send('cojer', 'Command', form);
			return;
		}
		if(!data.trim()) return;
	}
	if($data._$pending) $data._$pending.remove();
	$data._$pending = emulateMessage('pending', (typeof data == "string") ? data : "...", FA('spinner fa-spin', true), room.id)
		.addClass("act-pending-talk");
	
	ipc.send('cojer', 'Send', {
		type: type,
		room: room,
		data: data
	});
}
/**
 * 명령어 힌트 상태를 설정한다.
 * 
 * @param {boolean} visible 힌트 표시 여부
 * @param {string} text 검색 문자열
 * @param {string} chosen 선택된 명령어
 */
function setCommandHint(visible, text, chosen){
	let reg;
	let argv;
	let cArg;

	$data._shIndex = -1;
	delete $data._subhint;
	if(!text){
		delete $data._cmdText;
		$data._hint = visible = false;
		$stage.cmdHint.hide();
		return;
	}
	$data._cmdText = text;
	try{
		argv = text.slice(1).split(' ');
		reg = new RegExp(`^(${argv[0]})${(argv.length > 1) ? '$' : ''}`);
	}catch(e){
		$stage.cmdHint.hide();
		return;
	}
	if(visible){
		let list = CMD_LIST.filter(v => reg.test(v));
		let res = list.map(v => `
			<li id="chint-${v}">/${v.replace(reg, "<label class='chint-match'>$1</label>")} <label class="chint-usage">${L('cmdu-' + v)}</label><div class="chint-expl">%${v}%</div></li>
		`).join('');

		if(!chosen && list.length == 1){
			chosen = list[0];
			cArg = argv.length - 1;
		}
		if(chosen){
			res = res
				.replace(`>%${chosen}%`, ` style="display: block;">${L('cmdx-' + chosen)}`)
				.replace("chint-" + chosen, `chint-${chosen}" class="chint-chosen`);
			if(cArg) res += produceSubhint(list[0], cArg, argv[cArg], argv);
		}
		$stage.cmdHint.show().html(res);
		$data._hList = list;
	}else{
		$stage.cmdHint.hide();
	}
}
/**
 * 주어진 아이디를 가진 사용자의 채팅을 강조 표시한다.
 * 
 * @param {string} id 사용자 아이디
 */
function traceMessage(id){
	let already = $data._traced == id;

	$data._traced = id;
	$(".act-talk-traced").removeClass("act-talk-traced");
	if(OPT['no-trace']) return;
	if(already) delete $data._traced;
	else $(`.act-talk-${id}`).addClass("act-talk-traced");
}
/**
 * 해당 액티비티의 채팅 내용을 비운다.
 * 
 * @param {string} id 액티비티 식별자
 */
function clearBoard(id){
	let act = $data.acts[id];
	
	act._prevChat = act._lastMsgId;
	act.$stage.board.empty();
}
/**
 * 이미지에 대한 팝업을 띄운다.
 * 
 * @param {string} url 이미지 경로
 */
function popupImage(url){
	window.open(`./viewer.pug?url=${encodeURIComponent(url)}`);
}
/**
 * 방에 입장한다.
 * 
 * @param {string} cId 입장할 채팅방이 소속된 카페의 식별자
 * @param {string} rId 입장할 채팅방의 식별자
 */
function requestJoin(cId, rId){
	if($data.acts[rId.replace(":", "-")]) return error(100);
	ipc.send('cojer', 'Join', {
		cId: cId, rId: rId
	});
}
/**
 * 소리를 재생한다.
 * 
 * @param {string} key 소리 식별자
 */
function playSound(key){
	if(OPT['mute']) return;
	$sound[key].play();
}
/**
 * 유휴 상태를 해제한다.
 */
function breakIdle(){
	if($data.isIdle){
		Channel.send('status', { status: "online" });
	}
	$data.isIdle = false;
	$data._idle = 0;
}
/**
 * 유휴 상태를 확인한다.
 */
function checkIdle(){
	if($data.isIdle) return;
	if(++$data._idle >= OPT['idle-time']){
		$data.isIdle = true;
		Channel.send('status', { status: "afk" });
	}
}
/**
 * 풀에 포함되는 채팅인지 검사한다.
 * 
 * @param {string[]} pool 대상을 검사할 문자열을 담은 배열
 * @param {string} serial 문맥. "(아이디): (내용)" 꼴로 주어진다.
 * @returns {boolean} 포함되는 경우 true
 */
function checkBW(pool, serial){
	for(let i in pool) if(serial.match(new RegExp(pool[i]))) return true;

	return false;
}
/**
 * 오류를 알린다.
 * 
 * @param {number} code 오류 번호
 * @param {*} msg 부가 메시지
 */
function error(code, msg){
	alert(L(`error-${code}`, msg));
}let $stage;
let $sound;

$(() => {
	$data.localId = 0;
	// 스테이지 등록
	$stage = {
		body: $("body"),
		diag: {
			loginCaptcha: $("#diag-login-captcha-box"),
			loginOTP: $("#diag-login-otp-box"),
			loginOK: $("#diag-login-ok"),
			loginOut: $("#diag-login-output"),
			uploadImg: $("#diag-upload-img"),
			uploadOK: $("#diag-upload-ok"),
			ceOK: $("#diag-ce-ok"),
			statusList: $("#diag-status-list"),
			statusOK: $("#diag-status-ok"),
			bw: {
				_: $("#diag-bw"),
				bTable: $("#diag-bw-black"),
				bAdd: $("#diag-bw-black-add"),
				bCount: $("#diag-bw-black-count"),
				wTable: $("#diag-bw-white"),
				wAdd: $("#diag-bw-white-add"),
				wCount: $("#diag-bw-white-count"),
				ok: $("#diag-bw-ok")
			},
			macro: {
				_: $("#diag-macro"),
				list: $(".diag-macro-item"),
				ok: $("#diag-macro-ok")
			},
			find: {
				_: $("#diag-find"),
				input: $("#diag-find-input"),
				msgid: $("#diag-find-msgid"),
				status: $("#diag-find-status"),
				ok: $("#diag-find-ok"),
				back: $("#diag-find-back"),
				table: $("#diag-find-table")
			}
		},
		actTab: $("#act-tab"),
		acts: $("#activities"),
		cmdHint: $("#command-hint")
	};
	// 기존 설정 반영
	if(getAppMenu("chat-time").checked) onEvent(null, 'chat-time');
	if(getAppMenu("chat-list").checked) onEvent(null, 'chan-list');
	// 소리 등록
	$sound = {};
	[
		'k', 'alarm'
	].map(v => $sound[v] = new Audio(`media/${v}.mp3`));
	// 전역 입력 핸들링 / 유휴 상태 검사
	window.onmousemove = e => {
		breakIdle();
	};
	window.onkeydown = e => {
		breakIdle();
		switch(e.key){
			case 'Enter':
				$(".dialog:visible .ok-button:last").trigger('click');
				break;
			case 'Escape':
				$(".dialog:visible:last").hide();
				break;
			case 'Tab':
				if(e.ctrlKey){
					let $list = $(".at-item");
					let $c = $(".at-current");
					let len = $list.length;
					let vp;

					if(e.shiftKey) $c = $c.prev()[0];
					else $c = $c.next()[0];
					if(!$c) $c = $list.get(!e.shiftKey - 1);
					
					setActivity($c.id.slice(8));
					vp = $c.getBoundingClientRect();
					if(vp.left < 0) $("#at-wrapper").css('left', "-=" + vp.left);
					if(vp.left + vp.width > window.innerWidth) $("#at-wrapper").css('left', "-=" + (vp.left + vp.width - window.innerWidth))
				}
				break;
			default: return;
		}
	};
	setInterval(checkIdle, 1000);
	// 탭 순서 불러오기
	loadTabOrdinal();
	// 창에 드롭하는 경우
	document.body.addEventListener('dragenter', e => {
		$data._dType = e.dataTransfer.items[0].kind;
	});
	document.body.addEventListener('dragover', e => {
		$stage.body.addClass("dark-body");
		if($data._dType != "string"){
			e.preventDefault();
			e.stopPropagation();
		}
	});
	document.body.addEventListener('dragleave', e => {
		$stage.body.removeClass("dark-body");
	});
	document.body.addEventListener('drop', e => {
		$stage.body.removeClass("dark-body");
		if(!Activity.current.onChatPaste(e)){
			e.preventDefault();
			e.stopPropagation();
		}
	});
	// 로그인 대화 상자
	$stage.diag.loginOK.on('click', e => {
		$stage.diag.loginOK.prop('disabled', true);
		$stage.diag.loginOut.css('color', "").html("");
		if($data._loginForm && $data._loginForm['otp']) $data._loginForm['otp'] = $("#diag-login-otp").val();
		ipc.send('cojer', 'Login', {
			id: $("#diag-login-id").val(),
			pw: $("#diag-login-pw").val(),
			captcha: $("#diag-login-captcha").val(),
			captchaKey: $data._ckey,
			form: $data._loginForm,
			auto: $("#diag-login-auto").is(':checked'),
			disposable: $("#diag-login-disposable").is(':checked')
		});
	});
	// 업로드 대화 상자
	$stage.diag.uploadOK.on('click', e => {
		if($("#diag-upload-auto").is(':checked')) setOpt('no-ask-upload', true);
		$dialog('upload').hide();
		sendMessage('image', Activity.current.room, $data._uploading);
		delete $data._uploading;
	});
	// 채널 이메일 대화 상자
	$stage.diag.ceOK.on('click', e => {
		let pw = $("#diag-ce-pass").val();

		if(pw.length < 4 || pw.length > 20) return error(102);
		$stage.diag.ceOK.prop('disabled', true);
		$("#diag-ce-output").empty();
		$.post(`http://${CHANNEL_HOST}/ncc/set`, {
			key: $("#diag-ce-serial").val(),
			id: $data.myInfo.id,
			pw: pw,
			nickname: $data.myInfo.profile[Activity.current.room.cafe.id].nickname
		}, res => {
			$stage.diag.ceOK.prop('disabled', false);
			if(res.error) $("#diag-ce-output").html(L(`error-${res.error}`));
			else{
				notify(L('ce-ok'));
				setOpt('channel-pw', pw);
				$dialog('ce').hide();
				location.reload();
			}
		});
	});
	// 상태 대화 상자
	$stage.diag.statusOK.on('click', e => {
		Channel.send('status', { status: $stage.diag.statusList.val() });
		$dialog('status').hide();
	});
	// 대화 흑백 설정 상자
	$stage.diag.bw._.on('appear', e => {
		$data._bw_black = OPT['black'].map(v => v);
		$data._bw_white = OPT['white'].map(v => v);
		$stage.diag.bw._.trigger('change');
	}).on('change', e => {
		let putter;

		[ 'black', 'white' ].forEach(key => {
			let head = key.charAt();
			let $table = $stage.diag.bw[head + 'Table'];
			let arr = $data['_bw_' + key];

			$table.empty();
			$stage.diag.bw[head + 'Count'].html(L('diag-bw-count', arr.length));
			arr.forEach((v, i) => {
				$table.append(produceBWItem(key, i, v));
			});
		});
		$(".diag-bw-table-item>div").on('click', e => {
			let target = e.currentTarget;

			$data._bwEdit = target.parentNode.id.slice(11).split('-');
			target.parentNode.className = 'diag-bw-table-item diag-bw-ti-edit';
			$(target.parentNode).children('input').focus().trigger('keyup');
		});
		$(".diag-bw-table-item>input").on('keyup', e => {
			let target = e.currentTarget;
			let rx;

			$('.diag-bw-filter').removeClass('diag-bw-filter');
			if(target.value){
				try{ rx = new RegExp(target.value); }
				catch(e){ return; }
				if(rx) $('.act-talk').each((i, o) => {
					let $o = $(o);
					let id = $o.children('.actt-user').attr('title');
					let content;
					
					if(!id) return;
					id = id.match(/\((.+)\)$/)[1];
					content = id + ': ' + $o.children('.actt-body').text();
					
					if(content.match(rx)) $o.addClass('diag-bw-filter');
				});
			}
			if(event.which == 13) $(target).blur();
		}).each((i, o) => {
			o.onblur = onBlur;
		});
		if($data._bwEdit){
			$("#diag-bw-ti-" + $data._bwEdit).children("div").trigger('click');
		}
		function onBlur(e){
			let target = e.currentTarget;
			
			if(target.value) $data['_bw_' + $data._bwEdit[0]][$data._bwEdit[1]] = target.value;
			else $data['_bw_' + $data._bwEdit[0]].splice($data._bwEdit[1], 1);
			$('.diag-bw-filter').removeClass('diag-bw-filter');
			delete $data._bwEdit;
			setTimeout(() => $stage.diag.bw._.trigger('change'), 1);
		}
		function produceBWItem(type, i, rx){
			let onRemove = `
				$data._bw_${type}.splice(${i}, 1);
				$stage.diag.bw._.trigger('change');
			`;

			return `<div id="diag-bw-ti-${type}-${i}" class="diag-bw-table-item">
				<div class="diag-bw-ti-content">${rx.replace(/</g, "&lt;")}</div>
				<input id="diag-bw-tiv-${type}-${i}" class="diag-bw-ti-content" value="${rx}" placeholder="${L('diag-bw-placeholder')}"/>
				<button class="diag-action" onclick="${onRemove}">${FA('remove')}</button>
			</div>`;
		}
	});
	$stage.diag.bw.bAdd.on('click', e => {
		$data._bwEdit = 'black-' + ($data._bw_black.push("") - 1);
		$stage.diag.bw._.trigger('change');
	});
	$stage.diag.bw.wAdd.on('click', e => {
		$data._bwEdit = 'white-' + ($data._bw_white.push("") - 1);
		$stage.diag.bw._.trigger('change');
	});
	$stage.diag.bw.ok.on('click', e => {
		if(document.activeElement.className == "diag-bw-ti-content") return;
		setOpt({
			'black': $data._bw_black,
			'white': $data._bw_white
		});
		$dialog('bw').hide();
	});
	// 매크로 대화 상자
	$stage.diag.macro._.on('appear', e => {
		$stage.diag.macro.list.each((i, o) => {
			$(o).children("input").val(OPT['macro'][i]);
		});
	});
	$stage.diag.macro.ok.on('click', e => {
		let macro = [];

		$stage.diag.macro.list.each((i, o) => {
			macro[i] = $(o).children("input").val();
		});
		setOpt('macro', macro);
		$dialog('macro').hide();
	});
	// 대화 검색 대화 상자
	$stage.diag.find._.on('appear', e => {
		delete $data._findLast;
		$stage.diag.find.input.select().focus();
		$stage.diag.find.msgid.val("");
	}).on('disappear', e => {
		Activity.current.$stage.chat.focus();
	});
	$stage.diag.find.input.on('keydown', e => {
		if(e.shiftKey && e.key == 'Enter'){
			$stage.diag.find.back.trigger('click');
			e.stopPropagation();
		}
	}).on('keyup', e => {
		if($data._fInput != e.currentTarget.value) if($data._findLast){
			delete $data._findLast;
			$stage.diag.find.status.empty();
			$stage.diag.find.msgid.val("");
			$stage.diag.find.table.empty();
		}
		$data._fInput = e.currentTarget.value;
	});
	$stage.diag.find.ok.on('click', e => {
		let value = $stage.diag.find.input.val();
		let last = Number($stage.diag.find.msgid.val());

		if(!value) return;
		findChatting(value, {
			regex: $("#diag-find-opt-regex").is(':checked'),
			last: last ? (last - OPT['find-depth']) : null
		});
	});
	$stage.diag.find.back.on('click', e => {
		let value = $stage.diag.find.input.val();
		let last = Number($stage.diag.find.msgid.val());

		if(!value) return;
		findChatting(value, {
			regex: $("#diag-find-opt-regex").is(':checked'),
			last: last ? (last + OPT['find-depth']) : null
		});
	});
	// 특수 액티비티 등록
	$data.acts = {};
	$data.currentAct = ACT_OPENED;
	createActivity(ACT_OPENED, L('act-or-title'), `
		<select id="act-or-cafe-list">
			<option>${L('loading')}</option>
		</select>
		<div id="act-or-cafe-menu">
			<div class="act-or-cm-count"></div>
			<button id="act-or-cm-visit" title="${L('visit-cafe')}">${FA('external-link')}</button>
			<button id="act-or-cm-new" title="${L('act-or-cm-new')}">${FA('magic')}</button>
		</div>
		<div id="act-or-room-list"></div>
	`);
	$stage.cafeMenu = $("#act-or-cafe-menu");
	$stage.roomList = $("#act-or-room-list");
	$stage.cafeList = $("#act-or-cafe-list").on('mousedown', e => {
		$stage.cafeList.off('mousedown').children("option:first-child").html(L('act-or-cafe-list')).prop('disabled', true);
	}).on('change', e => {
		$data.currentCafe = $data.myInfo.cafeList[$stage.cafeList.val()];
		ipc.send('cojer', 'OpenRoomList', {
			cafe: $data.currentCafe
		});
	});
	$("#act-or-cm-new").on('click', e => {
		prompt(L('act-or-cm-new'), L('act-or-cm-title-default', $data.currentCafe.name)).then(res => {
			if(!res) return;
			ipc.send('cojer', 'CreateRoom', {
				cafe: $data.currentCafe,
				userList: [ $data.myInfo.id ],
				options: { name: res, isPublic: 'O' }
			});
		});
	});
	$("#act-or-cm-visit").on('click', e => {
		if(!$data.currentCafe) return error(105);
		shell.openExternal(CAFE_BOARD_URL($data.currentCafe.id));
	});
	// 자동 로그인 / 세션 처리
	if(OPT['auto']) ipc.send('cojer', 'Login', OPT.auto);
	else ipc.send('cojer', 'CheckAuth');
	// 업데이트 확인
	if(!OPT['no-update-notice']) checkUpdate();
	// 창 크기, 줌 기억
	if($data._zoom = localStorage.getItem('zoom')){
		webFrame.setZoomFactor(Number($data._zoom));
	}
	if($data._winSize = localStorage.getItem('winSize')){
		$data._winSize = $data._winSize.split(',').map(v => Number(v));
		Remote.getCurrentWindow().setSize($data._winSize[0], $data._winSize[1], false);
	}
	window.onbeforeunload = e => {
		localStorage.setItem('zoom', webFrame.getZoomFactor());
		localStorage.setItem('winSize', Remote.getCurrentWindow().getSize().join(','));
	};
});